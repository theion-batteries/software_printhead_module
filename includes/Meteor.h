/****************************************************
* Meteor.h
* Auto-generated header file - Do not edit this file
* Changes should be made to Meteor.cs
****************************************************/

#ifndef MeteorH
#define MeteorH

#include "typedef.h"

// Enumerate signal names for PiSetSignal command.
// PiSetSignal takes two parameters, SignalId and State.
// SignalId bits are formatted as follows:
// - Bits[31:24] contain the extended address (xaddr) for some signal types where noted; otherwise they should be zero
// - Bits[23:16] contain the pcc index (pccnum)
// - Bits[15:8] contain the hdc index (hdcnum)
// - Bits[7:0] contain a SigTypes value as defined below
// 
// SIG_OUTx and SIG_OENx control the I/O signals for each HDC. The SIG_OENx signal
// must be set first to enable the output. The SIG_OUTx identifiers
// also control the PCC outputs.
typedef enum {
   SIG_OUT1 = 0x00000000,   // Set the state of GPIO Output 1 (HDC or PCC)
   SIG_OUT2 = 0x00000001,   // Set the state of GPIO Output 2 (HDC or PCC)
   SIG_OUT3 = 0x00000002,   // Set the state of GPIO Output 3 (HDC or PCC)
   SIG_OUT4 = 0x00000003,   // Set the state of GPIO Output 4 (HDC or PCC)
   SIG_OEN1 = 0x00000004,   // Output enable for HDC GPIO 1 signal.  GPIO signals are not available on all HDCs : see hardware manual
                            // for details.  On some HDCs the GPIO signals are bidirectional and default to inputs.  To enable a
                            // signal as an output the corresponding SIG_OENx signals must be set to 1.
   SIG_OEN2 = 0x00000005,   // Output enable for HDC GPIO 2 signal
   SIG_OEN3 = 0x00000006,   // Output enable for HDC GPIO 3 signal
   SIG_OEN4 = 0x00000007,   // Output enable for HDC GPIO 4 signal
   SIG_HDPOWER = 0x00000008,   // Turns HDC power on or off on a per-PCC basis.  
                               // Normally not required; use PiSetHeadPower to control all heads simultaneously.
                               // 
                               // -- If hdcnum == 0 and state == 0, all HDCs on the PCC are immediately powered down.
                               // -- If hdcnum == 0 and state == 1, all "used" HDCs on the PCC are immediately powered up.
                               // 
                               // HDCs are "used" if they drive any heads which are listed in the [Planes] .cfg file section.
                               // The "used" state can also be changed at runtime as below:
                               // -- If hdcnum is set (1-8) and state == 0 the HDC is marked as unused and immediately powered down.
                               // -- If hdcnum is set (1-8) and state == 1 the HDC is marked as used.
                               // -- In this case the power state does not change until there is a call to either PiSetHeadPower or SIG_HDPOWER with state == 1 for the entire PCC.
                               // 
                               // A SIG_HDPOWER call (or a call to PiSetHeadPower) can start the hardware's HDC power state machine, which can take a few seconds to complete.
                               // The BMPS2_HEAD_POWER_IN_PROGRESS bit in TAppPccStatus.bmStatusBits2 reports whether the hardware HDC power state machine is busy.
                               // It is not possible to make a further HDC power change until this state machine has completed, so the application should check that 
                               // the BMPS2_HEAD_POWER_IN_PROGRESS bit in TAppPccStatus.bmStatusBits2 is clear before calling SIG_HDPOWER.
   SIG_PCLOCK = 0x00000009,   // Enable or disable the print clock at the specified PCC.
                              // 
                              // Should be called for the Master PCCs at least, to stop/start the clocks.
                              // By default the clock is enabled on startup.
   SIG_PDINTERVAL = 0x0000000A,   // Specify the interval for a repeating product detect generated internally by the FPGA.
                                  // Note that the value is at the printed image resolution; if single pass X interlacing is in use, it is divided down accordingly 
                                  // within the PrintEngine.
                                  // On the PCCE, more advanced product detect sequences can be set up by using <see cref="F:Ttp.Meteor.SigExTypes.SIGEX_PRODUCT_DETECT_QUEUE" />
                                  // instead of <see cref="F:Ttp.Meteor.SigTypes.SIG_PDINTERVAL" />
                                  // <i>xaddr </i>PCCE only: set to 1 to start the PD interval from an external PD
   SIG_SPIT = 0x0000000B,   // Do a number of spits (fire on every nozzle) on the specified HDC. It is also possible to spit on all HDCs, see parameters.
                            // Spit frequency is 8000Hz by default and can be changed by sending SIG_SET_TICKLE_FREQ
                            // Set pccnum = 0 and hdcnum = 0 to spit on all HDCs listed in the config file. (All connected PCCs and all listed HDCs)
                            // Set concrete pccnum and hdcnum = 0 to spit on all HDCs listed in the config for this particular PCC
   SIG_TTEST = 0x0000000C,   // Data Throughput Test signal
   SIG_VREG = 0x0000000D,   // FREG access for Vista
   SIG_FORCEPD = 0x0000000E,   // Force PD
   SIG_ENABLEPD = 0x0000000F,   // Enable/Disable internal and external PDs
   SIG_ENABLESCAN = 0x00000010,   // Enable/Disable start-of-scan detection for scanning printers
                                  // <i>xaddr </i>Ethernet only: set to 1 when disabling to automatically re-enable scan start detection within ~1ms of receiving a PD (home) signal
   SIG_ENABLETICKLE = 0x00000011,   // Enable/Disable automatic tickle mode
   SIG_START_FEEDBACK = 0x00000012,   // Start reading print data from FIFO path read buffers.  Feedback read data is written to a SimPrint file.
   SIG_UART = 0x00000013,   // Send 4 bytes to a printhead via its UART.  HT_KJ4 only.
   SIG_DEBUG_CONTROL = 0x00000014,   // Debug control signal.
   SIG_RUN_PCC_TEST = 0x00000015,   // Run a test on PCC hardware.
   SIG_STEPPER = 0x00000016,   // Start HDC-K GPIO stepper drive movement
   SIG_PDSKIP = 0x00000017,   // Ignore the next N product detects with N from 1 to 15
   SIG_LENGTH_ADJUST = 0x00000018,   // Set the LengthAdjust value to eat encoder pulses.  Call for master PCCs only.  
                                     // Equivalent to the configuration file parameter [Encoder] LengthAdjust = MODE, COUNT.
                                     // A length adjust value of 'N' lets 'N' encoder pulses through then discards the next pulse.
   SIG_SET_TICKLE_FREQ = 0x00000019,   // Set the tickle and spit (see SIG_SPIT) frequency (Hz). By default it is 8000Hz.
                                       // Absolute min/max values are:min: 82Hz, max: 100KHz. These are FPGA limits, concrete print head can have its own.
   SIG_FORCEWHITE = 0x0000001A,   // Force white print data for the head.  Available for most head types (contact support for an up to date list). 
                                  // Overrides the job's print data, and can be used while a print job is in progress.
                                  // For the HDC-2H2001, xaddr bits select which parts of the head the signal applies to
                                  // >--xaddr BIT0 applies the signal to Head1 Rows 1 and 2; xaddr BIT1 applies the signal to Head1 Rows 3 and 4;
                                  // ---xaddr BIT2 applies the signal to Head2 Rows 1 and 2; xaddr BIT3 applies the signal to Head2 Rows 3 and 4
                                  // For the HDC-R4, xaddr = 1 or 2 applies the signal to head 1 or head 2 only
                                  // For the KM1024i,KM1800i,KM1024,KM1800i_SH, xaddr BIT0 controls HD1R, BIT1 controls HD1L, BIT2 controls HD2R, BIT3 controls HD2L
                                  // For the Seiko 1024GS and RC1536, xaddr BIT[0][1][2][3] controls head 1 row [A][B][C][D]; xaddr BIT[4][5][6][7] controls head 2 row [A][B][C][D]
                                  // For the Xaar1201 and RicohTH5241, xaddr BIT[0][1][2][3] controls head rows [A][B][C][D] correspondingly
                                  // For the EpsonI3200  xaddr BIT[0..7] controls head row [A..H] correspondingly
                                  // <i>xaddr </i>0 applies the signal to the entire HDC.  See above for HDC types with more options.
   SIG_ADVANCE = 0x0000001B,   // Advance signal, breaks out of current loop of repeated documents and advances to the next document in the queue.  Ethernet PCCs only.
   SIG_CONFIG_HEAD_SCANDIR = 0x0000001C,   // Reload direction configuration to all print heads in scanning mode.  The application must set this signal before starting the carriage movement for the swath.  HDC-CF1, HDC-4CF1, HDC-2TT3 and HDC-L only.
   SIG_UPDATEINTERNALENCODER = 0x0000001D,   // Trigger an update of the internal encoder clock frequency, without requiring a StartJob.
   SIG_TOGGLE_MENISCUS = 0x0000001E,   // Kyocera K1200, K600 and K300 only. Allows on the fly switching on and off of meniscus activation. Switching between pixel modes that have different drop sizes is not allowed.
   SIG_HDPWR_SET_WDT = 0x0000001F,   // Set heads power watchdog timer. If after sending this signal another SIG_HDPWR_SET_WDT is not sent within the specified time interval, all HDCs will be powered off.
   SIG_RESERVED1 = 0x00000020,   // Reserved for internal use
   SIG_RESERVED2 = 0x00000021,   // Reserved for internal use
   SIG_RESERVED3 = 0x00000022,   // Reserved for internal use
   SIG_RESERVED4 = 0x00000023,   // Reserved for internal use
   SIG_RESERVED5 = 0x00000024,   // Reserved for internal use
   SIG_UPDATE_SORT_TIMING = 0x00000025,   // Trigger an immediate update of the sort registers; the values should be sent first using PiSetParam CCP_SORT_CONTROL
   SIG_FIREOUT_CONTROL = 0x00000026,   // FireOut control signal
   SIG_FORCE_HEAD_VOLTAGE = 0x00000027,   // head-specific. For SG600 head used to force HDC produce given voltage
   SIG_SKIP_DOC = 0x00000028,   // Skip document in memory based on it's 24-bit DocIdhead
   SIG_DLASE_CTRL = 0x00000029,   // head-specific. For DataLase head used to write magic control bits to the FPGA register
   SIG_PD_REPEAT = 0x0000002A,   // Specify the product detect repeat count: this is the *total* number of product detects that are generated from a single trigger
   SIG_CLEAR_PD_COUNT = 0x0000002B,   // Reset the product detect count for all PCCs to Zero.
   SIG_INT_PD_COUNT_MAX = 0x0000002C,   // **** Deprecated.  Will be removed in a future release.  ***
                                        // *** The more flexible <see cref="F:Ttp.Meteor.SigExTypes.SIGEX_PRODUCT_DETECT_QUEUE" /> signal can be used to specify in advance how many internal PDs to generate. ***
                                        // Set the maximum number of internal product detects to generate, counting from the point when SIG_CLEAR_PD_COUNT was last called.  
                                        // To avoid a race condition, SIG_CLEAR_PD_COUNT should be called before the internal PD is enabled with SIG_PDINTERVAL.
                                        // SIG_INT_PD_COUNT_MAX can be set before or after the internal product detect is enabled using SIG_PDINTERVAL.
                                        // If SIG_INT_PD_COUNT_MAX is set with a maximum count while the internal product detect is already running, it must be sufficiently 
                                        // ahead of the number of internal product detects which have already been generated.  If it is too close, too many PDs can be
                                        // generated.  An error is logged if this happens.
                                        // Ethernet platforms only.
                                        // When the internal PD is halted a <see cref="F:Ttp.Meteor.DocEventFlags.DocEventPdStopReached" /> event is set in the TAppStatus.DocIds array
   SIG_SET_HOME_OFFSET_PX = 0x0000002D,   // Set the homing offset in pixels for all PCCs.
                                          // This is the value which will be set in the absolute X register when a home command is received, either via PiSetHome or via a 
                                          // trigger on the Product Detect input.  The value persists over multiple home commands.
                                          // *** It is important that the registers are fully written to the hardware before PiSetHome is called.  The application must set this
                                          // signal using the synchronous PiSetAndValidateSignal function and wait for it to return before calling PiSetHome or triggering the
                                          // PD input ***
   SIG_PCC_DATACAP_CONTROL = 0x0000002E,   // PCC data capture control
   SIGTYPE_COUNT = 0x0000002F,   // Count of valid SigTypes
} SigTypes;

// Head/HDC type definitions.  Definitions of legacy eHEADTYPE values are retained for compatibility but may no longer be fully supported.
typedef enum {
   HT_NONE = 0x00000000,   // Default, indicates printer is not initialised
   HT_LEOPARD = 0x00000001,   // ** Deprecated ** Leopard/Xaar Omnidot318/TTEC CA3/CA4/CE2 etc.
   HT_SPECTRA = 0x00000002,   // Spectra Nova/Galaxy/S-Class
   HT_HSS = 0x00000003,   // Legacy implementation for Xaar 1001/1002/1003/1006 (HSS) driven by HDC-HLM. Being deprecated. Use HT_Xaar100X instead for new designs
   HT_KJ4 = 0x00000004,   // Kyocera KJ4
   HT_XJ500 = 0x00000005,   // Xaar XJ 500 ** Deprecated **
   HT_QCLASS = 0x00000006,   // Dimatix Q-Class.  ** Deprecated: use HT_QS256. **
   HT_POLARIS = 0x00000007,   // Polaris.  ** Deprecated: use HT_PQ512. **
   HT_CF1 = 0x00000008,   // ** Deprecated ** TTEC CF1
   HT_SPT_508GS = 0x00000009,   // ** Deprecated ** Seiko 508 greyscale
   HT_RG4 = 0x0000000A,   // Ricoh GEN4.  ** Deprecated: use HT_RicohGen4 or HT_RicohGen4L. **
   HT_RG5 = 0x0000000B,   // Ricoh Gen5/Gen5S/Gen6 heads on HDC-R5
   HT_LEXMARK = 0x0000000C,   // ** Deprecated ** Lexmark (Yellowstone)
   HT_SPT_254GS = 0x0000000D,   // ** Deprecated ** Seiko 254 greyscale
   HT_SPT_510BIN = 0x0000000E,   // ** Deprecated ** Seiko 510 binary
   HT_VISTA = 0x0000000F,   // Vista ** Deprecated **
   HT_STARFIRE = 0x00000010,   // Dimatix Starfire
   HT_PCCX_TESTBOARD = 0x00000011,   // PCC-X test board
   HT_SPT_RC512 = 0x00000012,   // ** Deprecated ** SII Printek RC512
   HT_RESERVED2 = 0x00000013,   // Reserved for future use
   HT_K1200 = 0x00000014,   // 1200DPI Kyocera KJ4
   HT_SPT_RC1536 = 0x00000015,   // SII Printek RC1536
   HT_K300 = 0x00000016,   // 300DPI Kyocera KJ4 (two colour head)
   HT_RESERVED = 0x00000017,   // Reserved for future use
   HT_K600 = 0x00000018,   // 600DPI Kyocera KJ4
   HT_SPT_1024GS = 0x00000019,   // SII Printek 1024GS
   HT_4CF1 = 0x0000001A,   // TTEC CF1, 4 heads mount
   HT_SAMBA = 0x0000001B,   // Dimatix Fujifilm Samba head
   HT_GH2220 = 0x0000001C,   // ** Deprecated ** Ricoh GH2220
   HT_KM_M600 = 0x0000001D,   // Konica Minolta M600SH MEMS heads family
   HT_KM130 = 0x0000001E,   // Konica Minolta ME130H 1200DPI MEMS head
   HT_KM1800I = 0x0000001F,   // Konica Minolta KM1800i 2-head HDC
   HT_KM1024I = 0x00000020,   // Konica Minolta KM1024iMAE, KM1024iMAE, KM1024iMHE, KM1024iSHE  2-head HDCs
   HT_K150 = 0x00000021,   // 150DPI Kyocera KJ4 (four colour head)
   HT_TTEC_CF3 = 0x00000022,   // TTEC CF3 head
   HT_TTEC_CK3 = 0x00000023,   // TTEC CK3 head
   HT_GMA33 = 0x00000024,   // ** Deprecated ** Dimatix GMA33 head
   HT_Xaar2001 = 0x00000025,   // Xaar2001 2-head HDC
   HT_KY0360 = 0x00000026,   // Kyocera KJ4B-0360 head
   HT_Xaar1201 = 0x00000027,   // Xaar1201 head
   HT_GMA99 = 0x00000028,   // Dimatix GMA99 head
   HT_SEIKO_SRC1800 = 0x00000029,   // Seiko SRC1800 head
   HT_KM1024 = 0x0000002A,   // Konica Minolta KM1024 (not I) head. Note that it is completely different to KM1024I
   HT_SG600 = 0x0000002B,   // Dimatix SG600 head
   HT_KY1200RM = 0x0000002C,   // Kyocera KJ4-1200 Recirculation Model
   HT_PQ512 = 0x0000002D,   // Dimatix QClass PQ_512 head. New software design for Polaris head (obsoletes HT_POLARIS)
   HT_QS256 = 0x0000002E,   // Dimatix QClass QS_256 head. New software design for Q-class (Sapphire) head (obsoletes HT_QCLASS)
   HT_DLase96 = 0x0000002F,   // DataLase laser print module
   HT_KM1800I_SH = 0x00000030,   // Konica Minolta KM1800i HDC driving a single head
   HT_KY0360_TF = 0x00000031,   // Kyocera KJ4C-0360 head
   HT_KM1024A = 0x00000032,   // Konica Minolta KM1024A head
   HT_RicohGen4 = 0x00000033,   // Ricoh Gen4 head. New software design for RG4 head (obsoletes HT_RG4)
   HT_RicohGen4L = 0x00000034,   // Ricoh Gen4L head.
   HT_EPSON_S3200 = 0x00000035,   // Epson S3200 head.
   HT_RicohGen5 = 0x00000036,   // Ricoh Gen5/Gen5S/Gen6 heads. New software design, currently only for HW configuration: PCC-Z + HMB-2R5
   HT_GMA65_300 = 0x00000037,   // Dimatix GMA6505300 (300DPI) head
   HT_KM1280I = 0x00000038,   // Konica Minolta KM1280iMHH-S 2-head HDCs
   HT_Xerox_W = 0x00000039,   // Xerox W-series head
   HT_EPSON_S800 = 0x0000003A,   // Epson S800 head.
   HT_EPSON_S1600 = 0x0000003B,   // Epson S1600 head.
   HT_EPSON_I1600 = 0x0000003C,   // Epson I1600 head.
   HT_EPSON_I3200 = 0x0000003D,   // Epson I3200-A1 4 colour 600-YDPI head.
   HT_Ricoh_TH5241 = 0x0000003E,   // Ricoh TH5241 head.
   HT_KY1200_MD = 0x0000003F,   // Kyocera KJ4B-1200-F16 Model
   HT_Xaar2001_BO = 0x00000040,   // Xaar2001 1-head special-purpose HDC
   HT_Xaar502_BO = 0x00000041,   // Xaar502 1-head special-purpose HDC
   HT_KY0600_EX = 0x00000042,   // Kyocera KJ4B-0600-20SP 2-head PDC
   HT_EPSON_I3200_HD = 0x00000043,   // Epson I3200-A1HD 2 colour 1200-YDPI head.
   HT_EPSON_D3000 = 0x00000044,   // Epson D3000 2 colour 1200-YDPI head.
   HT_Xaar100X = 0x00000045,   // New implementation for Xaar 1001/1002/1003/1006 and their more advanced variants (Nitrox) driven by HDC-HLM
   HT_Xaar200X = 0x00000046,   // HDC-H2001 driving one Xaar2001/2002 head
   HT_4Seiko_508GS = 0x00000047,   // 4 Seiko 508GS heads driven by HDC-2Sii1536 and adapter board
   HT_PJU_20 = 0x00000048,   // PJ unit with 20 "nozzles"
   HT_Ricoh_TH6310F = 0x00000049,   // Ricoh TH6310F head.
   HT_EPSON_T3200 = 0x0000004A,   // Epson T3200 head.
   HT_COUNT = 0x0000004B,   // Count of HT_xxx values
} eHEADTYPE;

// Firmware state machine states
// 
// It is assumed that the head is configured if the state is &gt; ST_CFGDONE
typedef enum {
   ST_OFF = 0x00000000,   // Head is powered off
   ST_NOCONN = 0x00000001,   // Head is not connected
   ST_NOTUSED = 0x00000002,   // Head is not used
   ST_HDCPWR = 0x00000003,   // Head Driver Card (HDC) is powered up
   ST_HDPWRWAIT = 0x00000004,   // Head power delay to reduce inrush current
   ST_HDPWR = 0x00000005,   // Head is powered up
   ST_CONFIG = 0x00000006,   // FPGA configuration is in progress
   ST_CFGDONE = 0x00000007,   // FPGA configuration is complete
   ST_WSYNC = 0x00000008,   // Head Driver Card (HDC) is configured, waiting to check that config was successful
   ST_SETUP = 0x00000009,   // Head setup is in progress (e.g. waveform downloading)
   ST_READY = 0x0000000A,   // Head setup is complete
   ST_VCCON = 0x0000000B,   // Vcc power applied
   ST_VAAON = 0x0000000C,   // Vaa power applied
   ST_RUNNING = 0x0000000D,   // Head Driver Card (HDC) is fully running.  Use the BMHS_CFGEND and BMHS_VCCEN bits in TAppHeadStatus::bmStatusBits to check when the head is ready to print.
   ST_VAAOFF = 0x0000000E,   // Vaa power has been removed (Vcc power is still applied)
   ST_VCCOFF = 0x0000000F,   // Vcc power has been removed
   ST_DROPCOUNINIT = 0x00000010,   // Initialise dropcounter (RG5 only)
   ST_DROPCOUNTDEINIT = 0x00000011,   // De-initialise dropcounter (RG5 only)
   ST_ENUM_COUNT = 0x00000012,   // must be the last member of this enum
} eHeadState;

#define BMPS_PLLBAD 0x00000001   // PLL went out of lock
#define BMPS_DDNEARLYFULL 0x00000002   // DDRAM is nearly full (CF reads are stalled if set)
#define BMPS_CPBADSYNC 0x00000004   // Command Processor detected command sequence error
#define BMPS_WFORM_REQ 0x00000008   // Waveform request from PC (for Vista head)
#define BMPS_HDPWR_WDT_EXPIRED 0x00000008   // This status flag indicates that PCC head power WDT has expired and all HDCs had been powered off.  Reuses the same value as BMPS_WFORM_REQ because Vista is kind of unsupported and we ran out of bits
#define BMPS_IPBUSY 0x00000010   // Receiving print data from USB
#define BMPS_DDFULL 0x00000020   // DDRAM is full
#define BMPS_USBHIGHSPEED 0x00000040   // USB connected at high speed (USB hardware platforms only)
#define BMPS_SPURIOUSPD 0x00000040   // A spurious product detect error is flagged if a PD is detected during the lockout period (Ethernet platforms only)
#define BMPS_CLEARACK 0x00000100   // Acknowledge to Clear Memory command
#define BMPS_ENC_ACTIVE 0x00000200   // Encoder is active
#define BMPS_PD_ACTIVE 0x00000400   // Product-detect is active
#define BMPS_MASTER 0x00000800   // PCC is Master (read back from PCC)
#define BMPS_PRINTING 0x00001000   // Actually printing
#define BMPS_SSREADY 0x00002000   // Images are in memory
#define BMPS_HDCPWR 0x00004000   // At least one HDC is powered
#define BMPS_HEADPWR 0x00008000   // At least one Head is powered
#define BMPS_IO_SIGNALS 0x00FF0000   // 8-bit input/output signal states
#define BMPS_FPGA_STATE 0x07000000   // 3-bit FPGA state field (FS_xxx)
#define BMPS_CFG_REQ 0x08000000   // HDC FPGA config request bit
#define BMPS_PCC_STATE 0xF0000000   // 4-bit Print Controller state field (PS_xxx)
#define SH_IO_SIGNALS 0x00000010   // Right-Shift Value for aligning the field at the lsb of IO Signals
#define SH_IO_OUT_SIGNALS 0x00000010   // Right-Shift Value for aligning the field at the lsb of output IO Signals
#define SH_IO_IN_SIGNALS 0x00000014   // Right-Shift Value for aligning the field at the lsb of input IO Signals
#define SH_FPGA_STATE 0x00000018   // Right-Shift Value for aligning the field at the lsb of FPGA State
#define SH_PCC_STATE 0x0000001C   // Right-Shift Value for aligning the field at the lsb of PCC State
#define BMPS2_DATA_XFER_ERROR 0x00000001   // PCC data transfer error detected. NOTE: Self clearing bit, so must check every time the status structure is read otherwise intermittent event could be missed.
#define BMPS2_PD_FAULT 0x00000002   // PD fault indicates printing has stopped due to too many missing PDs when using AutoPD.  Self-clearing.
#define BMPS2_TICKLE_EN 0x00000004   // Auto-tickle mode enabled on the PCC
#define BMPS2_DOC_NUM_ERR_HDC1 0x00000010   // Document number error flagged on hdc 1
#define BMPS2_DOC_NUM_ERR_HDC2 0x00000020   // Document number error flagged on hdc 2
#define BMPS2_DOC_NUM_ERR_HDC3 0x00000040   // Document number error flagged on hdc 3
#define BMPS2_DOC_NUM_ERR_HDC4 0x00000080   // Document number error flagged on hdc 4
#define BMPS2_DOC_NUM_ERR_HDC5 0x00000100   // Document number error flagged on hdc 5
#define BMPS2_DOC_NUM_ERR_HDC6 0x00000200   // Document number error flagged on hdc 6
#define BMPS2_DOC_NUM_ERR_HDC7 0x00000400   // Document number error flagged on hdc 7
#define BMPS2_DOC_NUM_ERR_HDC8 0x00000800   // Document number error flagged on hdc 8
#define BMPS2_HEAD_POWER_IN_PROGRESS 0x00001000   // Set if the PCC is in the process of powering HDCs or Heads on or off
#define BMPS2_EEPROM_DATA_READY 0x00002000   // Set if the HDC/HEAD EEPROM data is available (currently applies to SG600 only)

#define BMHS_CFGEND 0x80000000   // Bit31, HDC FPGA config end. Can be used alongside BMHS_VCCEN to determine if the head is powered.
#define BMHS_OVERCURRENT 0x40000000   // Bit30, HDC/Head overcurrent
#define BMHS_BADPIXELVAL 0x20000000   // Bit29, indicates that the top bit of 4bpp pixel data is set
#define BMHS_AMP_TEMP_ALARM 0x04000000   // Bit26, HDC amplifiers over temperature; head is powered off or waveform set to 0
#define BMHS_HIGH 0x02000000   // Bit25, Always high
#define BMHS_LOW 0x01000000   // Bit24, Always low (Meteor internal use only)
#define BMHS_IO 0x00F00000   // Bits[23..20] HDC I/O signals
#define BMHS_OVERTEMP 0x00800000   // Bit23, Head Driver IC overtemp (for KJ4 heads only)
#define BMHS_VAAEN 0x00080000   // Bit19, Head VaaEnable readback
#define BMHS_VCCEN 0x00040000   // Bit18,Head VccEnable readback. Can be used alongside BMHS_CFGEND to determine if the head is powered.
#define BMHS_CFDNO 0x00020000   // Bit17, Head CFDNO (Config Done) signal to indicate successful initialisation of the head (if applicable).
#define BMHS_xxxxxxxx 0x00010000   // Bit16, Spare bit currently
#define BMHS_ADC1 0x0000FF00   // Bits[15..8], ADC1 value
#define BMHS_ADC0 0x000000FF   // Bits[7..0], ADC0 value
#define BMHS_HEAD_REQUIRED 0x01000000   // Bit24, Head/HDC required by config file.  Can be cleared by marking a HDC listed in the config file as "unused", using SIG_HDPOWER.

// Print Controller state values.
// 
// Prioritised, so the printer state gets set to the highest of any of the
// PCC states. Note that at present, this table is assumed to match the
// <see cref="T:Ttp.Meteor.ePRINTERSTATE">MPS_xxx</see> table
typedef enum {
   PS_DISCONNECTED = 0x00000000,   // Initial value (used by PC)
   PS_CONNECTED = 0x00000001,   // Connected to PC
   PS_IDLE = 0x00000002,   // Waiting for print data
   PS_READY = 0x00000003,   // Have print data, not printing
   PS_PRINTING = 0x00000004,   // Printing
   PS_INITIALIZING = 0x00000005,   // Configuring FPGA
   PS_STARTUP = 0x00000006,   // Starting up
   PS_FAULT = 0x00000007,   // Serious fault
   PS_LOADING = 0x00000008,   // Loading
} ePCCSTATE;

// Compression modes, for sending data from the PC to the PCC with limited bandwidth.
typedef enum {
   Compression_None = 0x00000000,   // No Compression.
   Compression_Run_Length_Encoding = 0x00000001,   // Run-Length Encoding.
   Compression_Six_Grey_Levels = 0x00000002,   // Reduce 4 bits per pixel down to 6 grey levels.
} TCompressionModes;

// SIG_FIREOUT_CONTROL operations codes
typedef enum {
   EFOCtrl_None = 0x00000000,   // Invalid value
   EFOCtrl_SetPulse1_Delay = 0x00000001,   // Set FireOut Pulse1 delay in 12.5 ns units
   EFOCtrl_SetPulse2_Delay = 0x00000002,   // Set FireOut Pulse2 delay in 12.5 ns units
   EFOCtrl_SetPulse_Width = 0x00000003,   // Set FireOut Pulse width in 12.5 ns units
   EFOCtrl_SetHDC = 0x00000004,   // Set HDC[1..8] for FireOut
   EFOCtrl_SetDelayPulses = 0x00000005,   // Delay FireOuts for a specified number of fire pulses
   EFOCtrl_SetNumberOfPulses = 0x00000006,   // Set number of FireOut pulses. 0 for unlimited
   EFOCtrl_SetExpOff_Delay = 0x00000007,   // Set ExposureOFF delay in 12.5 ns units
} TFireOutControl;

// Id for the hardware tests that can be run on a PCC-E, see SIG_RUN_PCC_TEST
typedef enum {
   EPccHwTest_UdpEcho = 0x00000001,   // UDP Echo test
   EPccHwTest_TcpIp_DataPerf = 0x00000002,   // TCP/IP data transfer performance test
   EPccHwTest_PccE_FwUpd = 0x00000003,   // PCC-E FW update
} TPccHwTestId;

#define JT_FLAG_CONTINUE 0x80000000   // Flag can be set in the <see cref="F:Ttp.Meteor.CtrlCmdIds.PCMD_STARTJOB" /> Job Type field to allow the application to disconnect, then reconnect to the same job.
                                      // If a job using JT_FLAG_CONTINUE is already running when the PCMD_STARTJOB command is received, the application is allowed to reconnect to the running job.
#define JT_FLAG_RIGHTALIGN 0x40000000   // Flag can be set in the <see cref="F:Ttp.Meteor.CtrlCmdIds.PCMD_STARTJOB" /> Job Type field to change the meaning of the 
                                        // <see cref="F:Ttp.Meteor.CtrlCmdIds.PCMD_IMAGE" /> 'xleft' parameter for a single pass printer with media moving left-to-right
                                        // With this flag set, the parameter becomes 'xright', which defines the distance of the right-hand-side of the image from the 
                                        // right-hand-side of the document
#define JT_FLAG_ROTATEENABLE 0x20000000   // Flag can be set in the <see cref="F:Ttp.Meteor.CtrlCmdIds.PCMD_STARTJOB" /> Job Type field to enable image rotation for the job.
#define JT_FLAG_FASTMASKENABLE 0x10000000   // Flag can be set in the <see cref="F:Ttp.Meteor.CtrlCmdIds.PCMD_STARTJOB" /> Job Type field to enable fast masking for the job
#define PCMD_BLOCK_FLAG 0x80000000   // If the top bit of a command is set, PiSendCommand blocks until the PrintEngine has fully processed the command
                                     // This can be useful in a few situations: e.g. when starting a print job, so the application knows when the command has completed 
                                     // and can check whether it succeeded.  Normally, a PrintEngine return value isn't available, as the commands are buffered for 
                                     // performance reasons
                                     // *** USE WITH CARE *** Blocking commands can significantly degrade performance ***
#define APP_STATUS_VERSION 8   // Version of the <see cref="T:Ttp.Meteor.TAppStatus">TAppStatus</see> structure
#define APP_PCC_STATUS_VERSION 4   // OBSOLETE: This was previously used for the <see cref="F:Ttp.Meteor.TAppPccStatus.StructVersion" /> field.  TAppPccStatus.StructVersion now reports the TAppPccStatus structure size in bytes.
#define APP_HEAD_STATUS_VERSION 10   // Version of the <see cref="T:Ttp.Meteor.TAppHeadStatus">TAppHeadStatus</see> structure
#define CFWRITE_PROGRESS_MASK 0x000000FF   // 0 - 100%
#define CFWRITE_IN_PROGRESS 0x00000100   // Set during a compact flash write operation
#define CFPRESENT 0x80000000   // Compact flash card (PCC8) or UHS SD card (PCCE) is present
#define CFFAULT 0x40000000   // Compact flash fault
#define DATAPATH_OVERRIDE 0x40000000   // Obsolete: USB hardware only.  [ Bit set as part of the <see cref="F:Ttp.Meteor.CtrlCmdIds.PCMD_CF_HDIMAGE_BLK" /> command to override the dual FIFO datapath for the image. ]
#define DATAPATH_SELECT 0x20000000   // Obsolete: USB hardware only.  [ Select which dual FIFO datapath to use for <see cref="F:Ttp.Meteor.CtrlCmdIds.PCMD_CF_HDIMAGE_BLK" /> if <see cref="F:Ttp.Meteor.MeteorConsts.DATAPATH_OVERRIDE" /> is also set. ]
#define CF_HDIMAGE_FIRST_CMD 0x10000000   // When an image is split into multiple <see cref="F:Ttp.Meteor.CtrlCmdIds.PCMD_CF_HDIMAGE_BLK" /> commands, this bit should be set for the first command
#define CF_HDIMAGE_NOT_LAST_CMD 0x80000000   // When an image is split into multiple <see cref="F:Ttp.Meteor.CtrlCmdIds.PCMD_CF_HDIMAGE_BLK" /> commands, this bit should be set for all commands except the final one
#define DROPTUNER_STATUS_VERSION 5   // Version of the <see cref="T:Ttp.Meteor.TDropTunerStatus">TDropTunerStatus</see> structure
#define MAX_PCCS 255   // Maximum number of print controllers Meteor will handle
#define MAX_HDCS_PER_PCC 8   // Max number of HDCs supported by any PCC.
#define MAX_HEADS_PER_HDC 4   // Maximum number print heads on any HDC
#define MAX_JAS_PER_HEAD 16   // Max jetting assemblies supported by any head. Mostly for sanity checks, because JA is a pretty abstract thing
#define MAX_NOZZLE_ROWS_PER_HDC 8   // Maximum number of printhead nozzle rows which can be driven by a standard (LVDS connected) HDC
#define MAX_PLANES 32   // Max number of colour planes which support full PrintEngine / ScanEngine functionality.
                        // For some applications it is possible to use extended plane indexes greater than 32 in the configuration file.
                        // Some PrintEngine functionality is unavailable on Planes which have extended indexes.
#define MAX_Y_INTERLACE 12   // Max Y interlace levels
#define MAX_X_INTERLACE 8   // Max X interlace levels
#define MAX_HEADS_PER_PLANE 64   // Max heads per colour plane
#define MAX_TICK_PERIOD 800000   // 12.5ns units
#define MAX_FNAME_LEN 256   // Maximum number of characters accepted for a file path
#define MAX_WAVEFORM_FNAMES 100   // Maximum waveform filenames stored
#define MAX_PCC_OUTPUTS 4   // Output signals on PCC
#define MAX_PCC_INPUTS 4   // Input signals on PCC
#define MAX_DOC_IDS 64   // Max Doc IDs in <see cref="T:Ttp.Meteor.TAppStatus">TAppStatus</see>
#define MAX_SUBSYS 5   // The maximum number of sub-systems which can be driven by one PC running the PrintEngine.
                       // Each sub-system can drive a different head type, or can use the same head type configured differently (e.g. printing at
                       // a different X resolution).  Subsystems must be split at PCC boundaries.
#define MAX_WATERMARKS 16   // The maximum number of watermarks allowed in a single image.
#define CPS_PRINTING 1   // Bit set in TContinuousPrintStatus.StateFlags when printing is active
#define CPS_STARTED 2   // TContinuousPrintStatus.StateFlags flag set once printing starts;  Cleared by CCP_MONITOR_CONTINUOUS_PRINT
#define CPS_NO_MONITORED_HEADS 4   // TContinuousPrintStatus.StateFlags error bit if no continuous print monitor heads are selected
#define MAX_LICENCE_KEYS 10   // Maximum number of licence keys definable
#define SORT_USE_MASK 5   // Special value to use in PCMD_SORT to select a combination of outputs specified by [ControllerN] SortMask
#define BM_CFG_RELOAD_XOFFSETS 1   // Set this bit (BIT0) in PiReloadConfigValues to reload the X offsets from the config file
#define BM_CFG_RELOAD_YOFFSETS 2   // Set this bit (BIT1) in PiReloadConfigValues to reload the Y offsets from the config file
#define BM_CFG_RELOAD_WFMS 4   // Set this bit (BIT2) in PiReloadConfigValues to reload the waveform filenames from the config file
#define BM_CFG_RELOAD_DISABLED_NOZZLES 8   // Set this bit (BIT3) in PiReloadConfigValues to reload the [Planes] DisabledNozzlesPlaneN entries from the config file
#define BM_CFG_RELOAD_IMAGE_STORE_PARAMS 16   // Set this bit (BIT4) in PiReloadConfigValues to reload the image store related parameter from the config file
                                              // Should only be used for changes in [PCC8Flash] ReadMaskPdSyncOffset and ReadMaskImageLength; other changes require a re-init
#define BM_CFG_RELOAD_ADJUST_COLOUR_BALANCE 32   // Set this bit (BIT5) in PiReloadConfigValues to reload the [Planes] AdjustColourBalancePlaneN entries from the config file
#define BM_CFG_RELOAD_SCREEN_MODES 64   // Set this bit (BIT6) in PiReloadConfigValues to reload the [ScreenModeN] sections from the config file
#define BM_CFG_RELOAD_NOZZLE_COMPENSATION 128   // Set this bit (BIT7) in PiReloadConfigValues to reload the [NozzleCompensation] and [InterplanePlaneN] sections from the config file
#define BM_CFG_RELOAD_WATERMARK 256   // Set this bit (BIT8) in PiReloadConfigValues to reload the [Watermark] section from the config file
#define BM_CFG_RELOAD_TEMPERATURE_CONTRACTION 512   // Set this bit (BIT9) in PiReloadConfigValues to reload the [TemperatureContraction] section from the config file
#define MAX_MULTICHANNEL_FILE_BUFFERS 32   // Maximum number of image buffers that can be loaded from a multichannel image file
#define IMG_BUF_UNSET 0xFFFFFFFF   // Returned by PiAllocateImageBufferEx if image buffer allocation fails
#define DATAPATH_FEATURE_FIFO 1   // FIFO datapath available: see <see cref="F:Ttp.Meteor.TAppStatus.bmDatapathsAvailable" />
#define DATAPATH_FEATURE_PRELOAD 2   // PRELOAD datapath available: see <see cref="F:Ttp.Meteor.TAppStatus.bmDatapathsAvailable" />
#define DATAPATH_FEATURE_CFIMAGE 4   // PCMD_CFIMAGE available: see <see cref="F:Ttp.Meteor.TAppStatus.bmDatapathsAvailable" />.  Obsolete.
#define DATAPATH_FEATURE_SCREENPRO 8   // Screening of contone images available: see <see cref="F:Ttp.Meteor.TAppStatus.bmDatapathsAvailable" />
#define DATAPATH_FEATURE_RIP 16   // Raster Image Processing of pdf files, RGB TIFF files etc. available: see <see cref="F:Ttp.Meteor.TAppStatus.bmDatapathsAvailable" />
#define DATAPATH_FEATURE_PRINTFLAT 32   // PrintFlat calibration available: see <see cref="F:Ttp.Meteor.TAppStatus.bmDatapathsAvailable" />
#define DATAPATH_FEATURE_LOGPICOMMANDS 64   // Logging of commands at Printer Interface enabled"/&gt;

#define DocIdEventFlag 0x80000000   // If the top bit of a document id is set, this flags the value as a document event rather than a document id
#define DocEventPdStopReached 0x00000001   // The internal product detect stop count set by <see cref="F:Ttp.Meteor.SigTypes.SIG_INT_PD_COUNT_MAX" /> has been reached

#define BMHS3_HDC_LICENCE_MISSING 0x00000001   // Bit set if the HDC requires a licence and it is not present
#define BMHS3_HDC_ORIENTATION 0x00000002   // Bit set if the HDC Orientation is set to 1 in the configuration file

#define BM_spare0 0x00000001   // Spare
#define BM_INT_PD 0x00000002   // Use 'internal' product-detect
#define BM_Spare8 0x00000004   // Spare
#define BM_Spare6 0x00000008   // Spare
#define BM_INT_SE 0x00000010   // Use 'internal' shaft-encoder
#define BM_spare1 0x00000020   // Spare
#define BM_spare2 0x00000040   // Spare
#define BM_spare5 0x00000080   // Spare
#define BM_RTOL 0x00000100   // Transport direction is RtoL (actual)
#define BM_SCANNING 0x00000200   // Scanning printer
#define BM_PD_OFF 0x00000400   // Disable (main) PD input
#define BM_UNIDIR 0x00000800   // Unidirectional scanning
#define BM_PDLOCKOUT 0x00001000   // Lockout PDs during doc width
#define BM_FORCESORT 0x00002000   // Force sort signals active
#define BM_RESERVED 0x00004000   // Unused (was BM_TICKLE, now reported by Bmps.BMPS2_TICKLE_EN)
#define BM_Spare7 0x00008000   // Spare
#define BM_spare4 0x00010000   // Spare (previously was BM_RTOLCFG)
#define BM_STR_UNDER 0x00020000   // Strict under-run detect
#define BM_INT_PD_AUX 0x00040000   // Use 'internal' product-detect for aux lane (Ethernet only)
#define BM_PD_OFF_AUX 0x00080000   // Disable aux product detect input (Ethernet only)
#define BM_CONTINUOUS 0x00100000   // Continuous Mode (only available in FIFO mode)

#define BMMS_DUPLICATE_PCC_ID 0x00000001   // At least one PCC ID in the system is duplicated
#define BMMS_UNEXPECTED_PCC_ID 0x00000002   // At least one PCC in the system is not listed in the config file
#define BMMS_PCC_TYPE_MISMATCH 0x00000004   // At least one PCC in the system does not match the config file type
#define BMMS_ETHERNET 0x00000010   // Meteor is running on Ethernet enabled hardware
#define BMMS_MIXED_SUBSYSTEMS 0x00000020   // The Meteor configuration has multiple subsystem, used, for example, to mix different head types within one system

#define VALID_BPP_1 0x00000002   // 1 bits per pixel mode is valid
#define VALID_BPP_2 0x00000004   // 2 bits per pixel mode is valid
#define VALID_BPP_4 0x00000010   // 4 bits per pixel mode is valid
#define VALID_BPP_8 0x00000100   // 8 bits per pixel mode is valid

#define HDWS_OK 0x00000000   // No errors, everything is OK
#define HDWS_FILE_NOT_FOUND 0x00000001   // Waveform file not found
#define HDWS_FILE_INVALID 0x00000002   // Waveform file invalid
#define HDWS_WFILE_INDEX_UNUSED 0x00000003   // Selected waveform file index not listed in config file
#define HDWS_VSCALE_INVALID 0x00000004   // Voltage scaling invalid
#define HDWS_PULSE_COUNT_MISMATCH 0x00000005   // Mismatch between waveform files on the HDC.  All Dimatix waveforms generated by one HDC must have the same section/pulse count
#define HDWS_GENERIC_ERR 0x00000006   // Some generic error
#define HDWS_ERR_MASK 0x000000FF   // Error code mask. Error code occupies lowest byte, so error codes must be in a range [0..255]
#define HDWS_FLG_TICKLE_WF 0x00000100   // bit flag, specifies that error code applies to the ticking waveform

// Mask mode parameter supplied with PCMD_CFIMAGE (in ms 4 bits of xstart)
// and in PCMD_CFHDIMAGE (in ms 4 bits of xleft) commands
typedef enum {
   CFMASK_BOTH = 0x00000000,   // Mask both start and end of image (default)
   CFMASK_START = 0x00000001,   // Mask start of image only
   CFMASK_END = 0x00000002,   // Mask end of image only
   CFMASK_NEITHER = 0x00000003,   // Don't mask either end of image
   CFMASK_REVERSE = 0x00000004,   // Bit 2 swaps even/odd lines for mask
} CfMaskModes;

// Output buffer info structure.
// Structure used to transfer buffer-state info to the BuffInfo module
// for debug. bstate defined as uint32 to prevent structure-packing
// problem with VC++/Builder
typedef struct {
   uint32   bstate[2];   // Buffer state
   uint32   count[2];   // Dword count in buffer
   uint32   fbuff;   // Filling buffer
   uint32   sbuff;   // Sending buffer
   bool   bfull;   // Output buffer full
} TOpBuffInfo;

// Enum defining print resolutions, specified in the <see cref="F:Ttp.Meteor.CtrlCmdIds.PCMD_STARTJOB" /> command.
// Actual value is an index to a list of divider ratios in the config file
// (typically, 1, 2, 4)
typedef enum {
   RES_NONE = 0x00000000,   // Resolution not specified (RES_NONE is not a valid value for PCMD_STARTJOB)
   RES_HIGH = 0x00000001,   // High Resolution; selects the divider specified by [Encoder] Res1=xxx
   RES_MED = 0x00000002,   // Medium Resolution; selects the divider specified by [Encoder] Res2=xxx
   RES_LOW = 0x00000003,   // Lowest Resolution; selects the divider specified by [Encoder] Res3=xxx
   RES_MAX = 0x00000004,   // Count of resolution enumeration values, including RES_NONE (RES_MAX is not a valid value for PCMD_STARTJOB)
} eRES;

// Enum defining the job type, and controlling which data-paths are enabled.
typedef enum {
   JT_NONE = 0x00000000,   // JT_NONE disables both datapaths, so won't print.
   JT_PRELOAD = 0x00000001,   // JT_PRELOAD is for fixed (repeating) print jobs.
   JT_FIFO = 0x00000002,   // JT_FIFO is for variable print jobs (each document printed once only).
   JT_MIXED = 0x00000003,   // JT_MIXED is for background/overlay jobs (both paths enabled).
   JT_SCAN = 0x00000004,   // JT_SCAN is for scanning printers, otherwise the same as JT_FIFO.
   JT_RESERVED = 0x00000005,   // Reserved for future use.
   JT_DUAL_FIFO = 0x00000006,   // JT_DUAL_FIFO has two FIFO datapaths; (A) is a FIFO command queue for application managed PCCE memory; (B) is a standard command+data FIFO queue.  The application must set the memory boundary.  PCCE only.
} eJOBTYPE;

// Scan direction
typedef enum {
   SD_FWD = 0x00000000,   // Forward
   SD_REV = 0x00000001,   // Reverse
} eSCANDIR;

// Transport directions
typedef enum {
   TD_EW = 0x00000001,   // East-West (right-to-left)
   TD_WE = 0x00000003,   // West-East (left-to-right)
} eTDIR;

// HSS EEPROM usage options
typedef enum {
   HUT_NONE = 0x00000000,   // Do not use trim values from EEPROM
   HUT_SCLK = 0x00000001,   // Use only the SCLK value from EEPROM
   HUT_VOFFSET = 0x00000002,   // Use VOFFSET values from EEPROM
   HUT_PTRIM = 0x00000003,   // Use VOFFSET and PTRIM values from EEPROM
} eHUTSEL;

// Printer Commands - see Meteor documentation for usage details.
// 
// There are two types, Printing Command IDs and Control Command IDs.
// 
// Printing Command IDs. These commands are sent by the application via the
// Printer Interface using the PiSendCommand function. The specific dword format
// is used to allow a resync in case of data loss. These commands are queued.
// 
// Control Command IDs.  These commands are sent by the application via the
// Printer Interface. The commands are processed immediately and are not queued.
typedef enum {
   PCMD_NONE = 0x7A5535A0,   // NOP command id.
                             // A blocking NOP (i.e. PCMD_NONE | PCMD_BLOCK_FLAG) can be used as a mechanism to wait until a set of commands have been 
                             // fully processed by the PrintEngine, which can be useful during early development or for debug.
   PCMD_STARTJOB = 0x7A5535A1,   // StartJob command id
                                 // Cmd[0] = PCMD_STARTJOB
                                 // Cmd[1] = 4 (DWORD count); optionally 3 + N where N is the number of subsystems, if independent document widths are required
                                 // Cmd[2] = Job ID
                                 // Cmd[3] = Job Type <see cref="T:Ttp.Meteor.eJOBTYPE">eJOBTYPE</see>, ORed with optional job type flags <see cref="F:Ttp.Meteor.MeteorConsts.JT_FLAG_CONTINUE" />,
                                 // <see cref="F:Ttp.Meteor.MeteorConsts.JT_FLAG_RIGHTALIGN" />, <see cref="F:Ttp.Meteor.MeteorConsts.JT_FLAG_ROTATEENABLE" />, <see cref="F:Ttp.Meteor.MeteorConsts.JT_FLAG_FASTMASKENABLE" />
                                 // Cmd[4] = Resolution <see cref="T:Ttp.Meteor.eRES">eRES</see>
                                 // Cmd[5] = Document width (ignored for scanning or continuous print unless BM_PDLOCKOUT enabled)
                                 // Cmd[6] = Optional; document width for subsystem 2 in a mixed head type or mixed resolution configuration
                                 // Cmd[7...] = Optional document width for subsystem 3 etc. 
                                 // N.B. If a resolution divider is in use, the document width is at the *undivided* resolution (the config file's base 
                                 // resolution) for backwards compatibility.  When CCP_XRES_SCALE is used to change resolution, the document width is at the 
                                 // print resolution.
   PCMD_STARTFDOC = 0x7A5535A2,   // StartFifoDoc command id
                                  // Cmd[0] = PCMD_STARTFDOC
                                  // Cmd[1] = 1 or 2 (DWORD count); normally 1
                                  // Cmd[2] = Document ID (24 bits)
                                  // Cmd[3] = Optional: PccId (1-N) or 0 for all PCCs.  Should only be set in multi-master systems.
   PCMD_STARTPDOC = 0x7A5535A3,   // StartPreloadDoc command id
                                  // Cmd[0] = PCMD_STARTPDOC
                                  // Cmd[1] = 1 or 2 (DWORD count); normally 1
                                  // Cmd[2] = Copies (each copy of the document is triggered by a product detect)
                                  // Cmd[3] = Optional: PccId (1-N) or 0 for all PCCs.  Should only be set in multi-master systems.
   PCMD_IMAGE = 0x7A5535A4,   // SendImage command id
                              // Cmd[0] = PCMD_IMAGE
                              // Cmd[1] = Command DWORD count (4 + image DWORDs)
                              // Cmd[2] = [Bits7:0] Plane (1-128); other bits reserved (must be zero)
                              // Cmd[3] = XLeft (pixels) or XStart (pixels) for scanning or continuous print; XRight (pixels) if JT_FLAG_RIGHTALIGN is set
                              // Cmd[4] = YTop (pixels)
                              // Cmd[5] = Width (pixels)
                              // Cmd[6-N] = Image data
                              // N.B. When a print job resolution divider is in use, the x position is at the *undivided* resolution (the config file's base 
                              // resolution) for backwards compatibility.  When CCP_XRES_SCALE is used to change resolution, the x position is at the 
                              // print resolution.
   PCMD_HDIMAGE = 0x7A5535A5,   // SendHeadDriverCardImage command id, used to send image data to a single Head Driver Card, bypassing the Meteor image translator
                                // For most applications, it is recommended that PCMD_IMAGE is used rather than PCMD_HDIMAGE
                                // Cmd[0] = PCMD_HDIMAGE
                                // Cmd[1] = Command DWORD count (3 + hdc image DWORDs)
                                // Cmd[2] = PCC number (1-pcc count)
                                // Cmd[3] = Head Driver Card number (1-8)
                                // Cmd[4] = XStart (pixels)
                                // Cmd[5-N] = Head image data
   PCMD_ENDDOC = 0x7A5535A6,   // EndDocument command id
                               // Cmd[0] = PCMD_ENDDOC
                               // Cmd[1] = 0 (DWORD count) or 1 if documents are being targeted at specific PCCs
                               // Cmd[2] = Optional: PccId (1-N) or 0 for all PCCs.  If used, must match the document's PccId sent in PCMD_STARTFDOC or PCMD_STARTPDOC.
   PCMD_ENDJOB = 0x7A5535A7,   // EndJob command id
                               // Cmd[0] = PCMD_ENDJOB
                               // Cmd[1] = 0 (DWORD count)
   PCMD_TEST = 0x7A5535A8,   // Test command id
   PCMD_STARTSCAN = 0x7A5535A9,   // StartScan command id
                                  // Cmd[0] = PCMD_STARTSCAN
                                  // Cmd[1] = 1 (DWORD count)
                                  // Cmd[2] = Bit[0] Scan direction <see cref="T:Ttp.Meteor.eSCANDIR">eSCANDIR</see>; Bits[31:16] Scan offset (1/100th print clock - signed)
   PCMD_TIFFIMAGE = 0x7A5535AA,   // TiffImage command id
                                  // Cmd[0] = PCMD_TIFFIMAGE
                                  // Cmd[1] = 5 (DWORD count)
                                  // Cmd[2] = Bits[7:0] Plane (1-<see cref="F:Ttp.Meteor.MeteorConsts.MAX_PLANES">MAX_PLANES</see>); 
                                  // Bits[15:8] [ScreenMode] index (1-N) for a contone TIFF, 0 selects the default mode.
                                  // Bits[20:16] Grey level to use when printing a 1bpp TIFF at 2bpp or 4bpp.
                                  // Bit31 Set to start an asynchronous load of the TIFF file (no print commands are sent; a second PCMD_TIFFIMAGE command 
                                  // is needed to send the print data to the hardware)
                                  // Cmd[3] = XLeft (pixels) or XStart (pixels) for scanning or continuous print
                                  // Cmd[4] = YTop (pixels)
                                  // Cmd[5] = Lower 32 bits of pointer to buffer containing the TIFF filename
                                  // Cmd[6] = For 64 bit processes only, the upper 32 bits of the filename buffer address
                                  // N.B. When a print job resolution divider is in use, the x position is at the *undivided* resolution (the config file's base 
                                  // resolution) for backwards compatibility.  When CCP_XRES_SCALE is used to change resolution, the x position is at the 
                                  // print resolution.
   PCMD_SORT = 0x7A5535AB,   // Sort command id
                             // Cmd[0] = PCMD_SORT
                             // Cmd[1] = 2 (DWORD count)
                             // Cmd[2] = Pcc number (1-N)
                             // Cmd[3] = I/O number (1-4); 0 for no sort; 5 to select a combination of outputs defined by [ControllerN] SortMask
   PCMD_REPEAT = 0x7A5535AC,   // Repeat command id, for seamlessly repeating an image when using the preload path.
                               // PCMD_REPEAT should be sent after PCMD_STARTPDOC and before PCMD_IMAGE.
                               // It should not be used with the FIFO path.
                               // Cmd[0] = PCMD_REPEAT
                               // Cmd[1] = 1 (DWORD count)
                               // Cmd[2] = Repeat count (seamless repeats) bits23:0
                               // If a clean first copy start and final copy end is not required, Bit31 can be set.  This reduces PCC RAM usage.
   PCMD_RESERVED4 = 0x7A5535AD,   // Reserved for future use
   PCMD_CFIMAGE = 0x7A5535AE,   // CompactFlashImage command id.  Obsolete, do not use.
   PCMD_CF_WRITEFILE = 0x7A5535AF,   // CompactFlash WriteFile command id.  Obsolete, do not use.
   PCMD_RESERVED5 = 0x7A5535B0,   // Reserved for future use
   PCMD_CF_WRITE = 0x7A5535B2,   // CompactFlash Write command id
                                 // Cmd[0] = PCMD_CF_WRITE
                                 // Cmd[1] = Command DWORD count (2 + image data DWORDs)
                                 // Cmd[2] = PccNum (1 - N) [bits0:15]; HNum (1 - 8) or 0 [Bits16:23]; 
                                 // [Bits31:24] optional for status reporting [30:24] = progress percent; Bit31 = new doc flag
                                 // Cmd[3] = Starting block address
                                 // Cmd[4-N] = Image data
   PCMD_CF_HDIMAGE = 0x7A5535B3,   // CompactFlash HeadImage command id.  Obsolete, use PCMD_CF_HDIMAGE_BLK.
   PCMD_BIGIMAGE = 0x7A5535B4,   // SendBigImage ( > 60MBytes ) command id
                                 // Application must continually retry PiSendCommand using the same buffer while RVAL_FULL is returned
                                 // Cmd[0] = PCMD_BIGIMAGE
                                 // Cmd[1] = Command DWORD count (5 + image DWORDs)
                                 // Cmd[2] = Plane (1-<see cref="F:Ttp.Meteor.MeteorConsts.MAX_PLANES">MAX_PLANES</see>)
                                 // Cmd[3] = XLeft (pixels)
                                 // Cmd[4] = YTop (pixels)
                                 // Cmd[5] = Width (pixels)
                                 // Cmd[6] = Height (pixels)
                                 // Cmd[7-N] = Image data
   PCMD_REVERSE_PRINT = 0x7A5535B5,   // Next doc will be printed in reverse (in non-scanning mode)
   PCMD_CFWRITE_RES = 0x7A5535B6,   // Set the resolution for all subsequent compact flash writes, and optionally the transport direction
                                    // Cmd[0] = PCMD_CFWRITE_RES
                                    // Cmd[1] = 1 or 2(Command DWORD count)
                                    // Cmd[2] = RES_HIGH, RES_MED or RES_LOW 
                                    // Cmd[3] = 1 (reverse), 0 (forwards - default value)
   PCMD_CF_HDIMAGE_BLK = 0x7A5535B7,   // Flash memory (CompactFlash) block aligned HeadImage command id
                                       // Top bits of CMD[4] set as follows:        
                                       // BIT31: Set if image split into multiple cmds and this is not the last cmd.
                                       // BIT28: Set if image split into multiple cmds and this is the first cmd.
                                       // PCC8 only - BIT30: Set to override docID dual-FIFO datapath selection; BIT29: Select datapath.
                                       // Cmd[0] = PCMD_CF_HDIMAGE_BLK
                                       // Cmd[1] = 5 (Command DWORD count)
                                       // Cmd[2] = PccNum (1 - N)
                                       // Cmd[3] = HNum (1 - 8)
                                       // Cmd[4] = BITS0-23: X Start (pixels); see above for flags in upper 4 bits
                                       // Cmd[5] = X Length (pixels)
                                       // Cmd[6] = Starting flash block address (flash memory cards are arranged in 512-byte blocks)
   PCMD_RESERVED3 = 0x7A5535B8,   // Reserved for future use
   PCMD_RESERVED2 = 0x7A5535B9,   // Reserved for future use
   PCMD_PRINT_RAM_IMAGE = 0x7A5535BA,   // Print Image Stored in PCC RAM
                                        // Used to instruct PCC to print image previously stored in RAM
                                        // Cmd[0] = PCMD_PRINT_RAM_IMAGE
                                        // Cmd[1] = Command DWORD count: 3 for standard printing, 4 for circular printing, 5 to target a single PCC
                                        // Cmd[2] = Image Reference Number, 0 - unsigned 32-bit integer (this will be used to identify this image for later PCMD_PRINT_RAM_IMAGE commands)
                                        // Cmd[3] = X Start (pixels)
                                        // Cmd[4] = Width (pixels); used for image positioning within the document when printing is left-to-right.  Should normally match the width in PCMD_WRITE_RAM_IMAGE_EX.
                                        // Cmd[5] = [Optional] X Offset (pixels) within the image for circular printing, 0 (default) when circular printing is not in use
                                        // Cmd[6] = [Optional] Index of the single PCC (1-N) to receive the image, 0 (default) for all PCCs
   PCMD_WRITE_RAM_IMAGE = 0x7A5535BB,   // ** Deprecated; use PCMD_WRITE_RAM_IMAGE_EX instead **
                                        // Write Image to PCC RAM
                                        // Used to instruct PCC to write image to RAM, which can then be printed with PCMD_PRINT_RAM_IMAGE
                                        // Cmd[0] = PCMD_WRITE_RAM_IMAGE
                                        // Cmd[1] = Command DWORD count (4 + image DWORDs)
                                        // Cmd[2] = Image Reference Number, 0 - unsigned 32-bit integer (this will be used to identify this image for later PCMD_PRINT_RAM_IMAGE commands)
                                        // Cmd[3] = [Bits7:0] Plane (1-<see cref="F:Ttp.Meteor.MeteorConsts.MAX_PLANES">MAX_PLANES</see>); Bit31 set for circular printing; Bit30 set if more images (of the same width) for the same reference will follow
                                        // Cmd[4] = YTop (pixels)
                                        // Cmd[5] = Width (pixels)
                                        // Cmd[6-N] = Image data
   PCMD_IMAGE_BUFFER = 0x7A5535BC,   // Send an image from an image buffer previously allocated and filled by PiAllocateTiffImageBuffer, or allocated by 
                                     // PiAllocateImageBufferEx and filled with PiFillImageBuffer, etc.
                                     // Note that PiFillImageBuffer is available only when the calling application is also hosting the Meteor Print Engine
                                     // Note also that it is the application's responsibility to free the image buffer when it is no longer required
                                     // If the buffer will only be used once, it can be automatically freed by setting BIT31 of the 'Plane' parameter
                                     // A buffer can be freed at any time by setting plane to 0 (in this case 'Xleft', 'Ytop' and 'Width' are ignored)
                                     // Cmd[0] = PCMD_IMAGE_BUFFER
                                     // Cmd[1] = Command DWORD count (5, or 7 for y interlacing)
                                     // Cmd[2] = Plane (1-<see cref="F:Ttp.Meteor.MeteorConsts.MAX_PLANES">MAX_PLANES</see>).  Top bit set to free buffer.  
                                     // Send Plane == 0 to free buffer without printing.
                                     // Cmd[3] = XLeft (pixels) or XStart (pixels) for scanning or continuous print
                                     // Cmd[4] = YTop (pixels)
                                     // Cmd[5] = Width (pixels).  If the buffer has been loaded from an image file (PiAllocateTiffImageBuffer etc.) the width 
                                     // should be set to zero (which means use the file's width)
                                     // Cmd[6] = Image buffer Id
                                     // Cmd[7] = Optional:  Y interlace 'N': the print takes 1 in N lines from the image buffer
                                     // Cmd[8] = Optional:  Interlace offset, 0 to N - 1: which of the N interlace lines to print
   PCMD_RESERVED = 0x7A5535BD,   // Reserved for future use
   PCMD_WRITE_RAM_IMAGE_EX = 0x7A5535BE,   // Write Image to PCC RAM
                                           // Used to instruct PCC to write image to RAM, which can then be printed with PCMD_PRINT_RAM_IMAGE
                                           // The amount of memory reserved for the reference can be defined with the "Reserved Width" parameter the first time the reference is used in a print job
                                           // The commands to send the print data for the different colour planes in an image should be sent in sequence using the same "Reference Number";
                                           // the "more images" flag (BIT30 of Cmd[4]) must be set for all but the final image in the sequence.  The translated image data is sent to 
                                           // PCC memory during this final command (i.e. when the "more images" bit is clear). N.B. The PrintEngine's Rx:WriteRamImageEx log entry
                                           // shows the inverse of more images as 'SendToHardware'.
                                           // Cmd[0] = PCMD_WRITE_RAM_IMAGE_EX
                                           // Cmd[1] = Command DWORD count (6 + image DWORDs)
                                           // Cmd[2] = Header DWORD count (5)
                                           // Cmd[3] = Image Reference Number, 0 - unsigned 32-bit integer (this will be used to identify this image for later PCMD_PRINT_RAM_IMAGE commands)
                                           // Cmd[4] = [Bits7:0] Plane (1-<see cref="F:Ttp.Meteor.MeteorConsts.MAX_PLANES">MAX_PLANES</see>); Bit31 set for circular printing; 
                                           // Bit30 set if more images (of the same width) for the same reference will follow; Bit29 sets scan direction (clear=FWD, set=REV); 
                                           // Bit28 set to use an image buffer allocated by PiAllocateTiffImageBuffer in place of image data.
                                           // Cmd[5] = YTop (pixels)
                                           // Cmd[6] = Width (pixels)
                                           // Cmd[7] = Reserved Width (pixels); if zero the slot size is set by the Width (pixels).  Used the first time a slot is written during a print job.
                                           // Cmd[8-N] = Image data; or an image buffer ID if Cmd[4] Bit28 is set.
   PCMD_CF_TRANSLATEIMAGE = 0x7A5535BF,   // Prepare an image for writing to Flash memory (PCC8 Compact Flash or PCCE UHS SD Card) using the translator
                                          // Either the image can be sent as part of the command starting at DWORD offset 16, or image data previously loaded into a 
                                          // PrintEngine image buffer can be used
                                          // An image can be loaded into an image buffer via PiAllocateImageBufferEx and PiFillImageBuffer; PiAllocateTiffImageBuffer; or 
                                          // PiAllocateMultichannelFileBuffers
                                          // The image buffer is automatically deallocated once the Flash data has been processed if the top bit of Cmd[2] is set
                                          // PiAllocateImageBufferEx and PiFillImageBuffer are available only when the calling application is also hosting the 
                                          // Meteor Print Engine
                                          // Cmd[0] = PCMD_CF_TRANSLATEIMAGE
                                          // Cmd[1] = Command DWORD count (5 or 6 when using an image buffer; 16 + image DWORDs when the command contains the image)
                                          // Cmd[2] = Plane (1-<see cref="F:Ttp.Meteor.MeteorConsts.MAX_PLANES">MAX_PLANES</see>).  Set top bit (BIT31) to free image buffer after use.
                                          // Set BIT30 to ignore any previously set CCP_FORCE_WHITE_IMAGE values.  Set BIT29 for parallel processing (the image buffers
                                          // must persist until the PCMD_CF_STOREIMAGE call).  Send Plane == 0 to free buffer without using its contents.
                                          // Cmd[3] = YTop (pixels)
                                          // Cmd[4] = Width (pixels).  If an image buffer is used, Width should be set to zero (which means use the image buffer's width).
                                          // Cmd[5] = Image buffer ID; -1 to fill all head Flash memory slots with zero up to the zero fill width [Ignored if the image data
                                          // is sent as part of the command buffer]
                                          // Cmd[6] = Zero fill width (pixels); must be greater or equal to the image width
                                          // Cmd[7] = [Optional] X start offset
                                          // Cmd[8] = [Optional] Image height in pixels, required only when the command contains raster image data
                                          // Cmd[9-15] = [Optional] Reserved; should be zero
                                          // Cmd[16-N] = [Optional] Image data
   PCMD_CF_STOREIMAGE = 0x7A5535C0,   // Write the images prepared using PCMD_CF_TRANSLATEIMAGE to flash memory
                                      // This should be called after the images for every plane have been prepared
                                      // The calling application is responsible for allocating flash memory block addresses
                                      // Cmd[0] = PCMD_CF_STOREIMAGE
                                      // Cmd[1] = Command DWORD count (8)
                                      // Cmd[2] = Starting block address for HDC 1 on all PCCs
                                      // Cmd[3] = Starting block address for HDC 2 on all PCCs
                                      // Cmd[4] = Starting block address for HDC 3 on all PCCs
                                      // Cmd[5] = Starting block address for HDC 4 on all PCCs
                                      // Cmd[6] = Starting block address for HDC 5 on all PCCs
                                      // Cmd[7] = Starting block address for HDC 6 on all PCCs
                                      // Cmd[8] = Starting block address for HDC 7 on all PCCs
                                      // Cmd[9] = Starting block address for HDC 8 on all PCCs
   PCMD_CF_MASKOFFSET = 0x7A5535C1,   // Enable circular masking mode for the Compact Flash.  This is used to start each print at an offset
                                      // through the image, determined by a sync signal connected to the auxiliary PCC8 PD input.  HDC-SF only.
                                      // This command overrides the configuration file values [PCC8Flash] EnableReadMask, ReadMaskPdSyncOffset and ReadMaskImageLength
                                      // Cmd[0] = PCMD_CF_MASKOFFSET
                                      // Cmd[1] = Command DWORD count (3)
                                      // Cmd[2] = Enable or disable the mask mode
                                      // Cmd[3] = Offset through the image in pixels at the sync mark; depends on the relationship between the sync mark and the product detect
                                      // Cmd[4] = Image length in pixels
   PCMD_SET_CONTINUOUS_PRINT = 0x7A5535C2,   // Similar to CCP_SET_CONTINUOUS_PRINT, except switches continuous mode on or off synchronously with the print queue
                                             // Can be used to switch a running print job between continuous and non-continuous mode
                                             // Cmd[0] = PCMD_SET_CONTINUOUS_PRINT
                                             // Cmd[1] = Command DWORD count (1)
                                             // Cmd[2] = Enable (1) or disable (0) continuous print
   PCMD_TRACER = 0x7A5535C3,   // Send a tracer command to each PCC in the system.  The application status TracerCount is incremented once the commands have
                               // been processed by every PCC.  Applies to Ethernet hardware only.
                               // This allows the application to insert a tracer in the print data stream to track when the print data arrives at the hardware.
                               // This is primarily intended for use in continuous print mode.  Note that in continuous mode, sending a tracer after a PCMD_IMAGE
                               // tracks when the *previous* part of the image arrives at the hardware, because the latest part of the image is held in PC
                               // memory for handling seamless overlaps.
                               // If used for product detect driven discrete printing when PCMD_ENDDOC commands are being sent, the tracer should come after
                               // the end doc
                               // Cmd[0] = PCMD_TRACER
                               // Cmd[1] = Command DWORD count (1)
                               // Cmd[2] = BIT0: Set to Reset tracer count, clear to tracer increment
   PCMD_IMAGEEX = 0x7A5535C4,   // Coming soon ....SendImageEx command id
                                // Cmd[0] = PCMD_IMAGEEX
                                // Cmd[1] = Command DWORD count (30 + image DWORDs)
                                // Cmd[2] = Plane (1-<see cref="F:Ttp.Meteor.MeteorConsts.MAX_PLANES">MAX_PLANES</see>)
                                // Cmd[3] = XLeft (pixels) or XStart (pixels) for scanning or continuous print
                                // Cmd[4] = YTop (pixels)
                                // Cmd[5] = Width (pixels)
                                // Cmd[6] = Height (pixels)
                                // Cmd[7] = Format and alignment flag:
                                // Cmd[8] = Print data stride in 32 bit DWORDs (if line N starts at offset L in the buffer, line N+1 starts at offset L+stride)
                                // Cmd[9] = Print data bit depth
                                // Cmd[10-31] = Reserved for future use.  Must be zero.
                                // Cmd[32-N] = Image data
   PCMD_RIPIMAGE = 0x7A5535C5,   // Rip-and-print image command id
                                 // RIPs the image and prints it either as individual FIFO or PRELOAD documents, or as a continuous FIFO document if the job is running
                                 // in continuous mode (which can be set in the config file, or by calling PCMD_SET_CONTINUOUS_PRINT)
                                 // The RIP config should be the name of a file in the HHR SW\TestConfig folder; alternatively send "" or a null pointer to use the 
                                 // default RIP config
                                 // The PiSendRipImageCommandHelper method can be used to hide the marshalling of the two strings for managed code, or set the 
                                 // pointers for unmanaged code.  If set directly in unmanaged code, the strings must be wchar_t pointers
                                 // Note that the Harlequin RIP is only available when running the 64 bit PrintEngine
                                 // Cmd[0] = PCMD_RIPIMAGE
                                 // Cmd[1] = 32 (command DWORD count)
                                 // Cmd[2] = Lower 32 bits of pointer to buffer containing the name of the file to rip-and-print
                                 // Cmd[3] = For 64 bit processes only, the upper 32 bits of the filename buffer address
                                 // Cmd[4] = Lower 32 bits of pointer to buffer containing the RIP config
                                 // Cmd[5] = For 64 bit processes only, the upper 32 bits of the RIP config buffer address
                                 // Cmd[6] = [BIT7:0] Plane (P) for channel 1 of the ripped image; P is indexed from 1; channel N of the ripped image uses plane P + (N-1)
                                 // [BIT15:8] Plane (P') for channel 1 of alternate pages in double sided printing
                                 // Cmd[7] = XLeft (pixels) or XStart (pixels) for scanning or continuous print
                                 // Cmd[8] = YTop (pixels) for all colour planes
                                 // Cmd[9] = X gap (pixels) between pages for continuous print
                                 // Cmd[10] = First page to RIP (0 for all pages)
                                 // Cmd[11] = Last page to RIP (0 for all pages)
                                 // Cmd[12] = Control flags: 
                                 // [BITS1:0] rotate in multiples of 90 degrees: 0 = 0; 1 = -90; 2 = 180; 3 = 90; 
                                 // [BIT2] set = mirror along the X axis
                                 // [BIT3] set = TAppStatus.TracerCount increments once each page is loaded to the hardware (Ethernet only)
                                 // [BIT4] clear = FIFO; set = PRELOAD
                                 // [BIT5] set = double sided mode; each colour has two sets of planes; odd pages print on plane P, even pages on plane P'
                                 // Cmd[13] = In FIFO mode, the Doc Id for the first page in the document; incremented for each page when printing a page per Product Detect
                                 // Cmd[14] = In preload mode, the number of copies of each page to print
                                 // Cmd[15] = Reserved for future use.  Must be zero.
                                 // Cmd[16] = Reserved for future use.  Must be zero.
                                 // Cmd[17-34] = Reserved for future use.  Must be zero.
   PCMD_ROTATE = 0x7A5535C6,   // Rotate an image in range of [-45, +45] degrees immediately before translating.
                               // It can also be used to scale the image in x and y before rotating (or set angle to 0 to scale without rotation).
                               // See the Image Rotation Application Note for more examples and explanation.
                               // Images with a large aspect ratio cannot be rotated as far, a 4:1 image can only be rotated by ~[-14,+14]. Limitation for this is
                               // tan(|angle|) &lt; height/width.
                               // Sufficient time must be given to the PrintEngine to rotate and translate the image before media reaches the print heads.
                               // Therefore it is highly recommended that you enable fast translation and parallel translation.
                               // This command must be sent before each image command sent, if it is not and image rotation is enabled then the print will abort.
                               // Cmd[0] = PCMD_ROTATE
                               // Cmd[1] = 7 (command DWORD count)
                               // Cmd[2] = Signed 32-bit integer describing rotation angle in 10^-7 degree steps, i.e. rotation angle = Cmd[2]/10^7.
                               // Cmd[3] = Optional additional adjustment in x (pixels) where the coordinate system has been rotated with the image.
                               // Cmd[4] = Optional additional adjustment in y (pixels) where the coordinate system has been rotated with the image.
                               // Cmd[5] = Tile width, required if the image is a different size to the tile activating the product detect. 0 => use image width.
                               // Cmd[6] = Tile height, required if the image is a different size to the tile activating the product detect. 0 => use image height.
                               // Cmd[7] = Optional signed 32-bit integer to scale the width of the image up or down, new width (px) = image width + this value.
                               // Cmd[8] = Optional signed 32-bit integer to scale the height of the image up or down, new height (px) = image height + this value.
   PCMD_NOZZLECOMP = 0x7A5535C7,   // Configure same plane nozzle compensation for a single plane. For more information about these values, see documentation.
                                   // Cmd[0] = PCMD_NOZZLECOMP
                                   // Cmd[1] = 14 (command DWORD count)
                                   // Cmd[2] = Plane (1-N):               The plane to which this nozzle compensation configuration refers
                                   // Cmd[3] = SamePlaneMode:             Selection of same-plane compensation mode type : 0 = No compensation (i.e. disable nozzles only), 1 = compensation enabled
                                   // Cmd[4] = SampleExtentVertical:      Vertical extent for compensation sample
                                   // Cmd[5] = SampleExtentHorizontal:    Horizontal extent for compensation sample
                                   // Cmd[6] = SamePlaneDensityOffset:    Offset value for compensation (in units of 1/100)
                                   // Cmd[7] = SamePlaneDensityGain:      Gain value for compensation (in units of 1/100)
                                   // Cmd[8] = InterPlaneDensityOffset:   Alternative offset value, used when InterplaneCompMode = 4 (in units of 1/100)
                                   // Cmd[9] = InterPlaneDensityGain:     Alternative gain value, used when InterplaneCompMode = 4 (in units of 1/100)
                                   // Cmd[10] = InterPlaneThreshold:      Local plane density threshold to be used when inter-plane compensation mode = 2, 3 or 4 (from 0.0 to 1.0, in units of 1/100)
                                   // Cmd[11] = MaxAllowedGrayLevel:      Limit maximum pixel gray level, 0 is no limit
                                   // Cmd[12] = MaxAllowedGrayDelta:      Maximum number of gray levels any compensating pixel can be incremented, 0 is no limit
                                   // Cmd[13] = Reserved for future use.  Must be zero.
                                   // Cmd[14] = Reserved for future use.  Must be zero.
                                   // Cmd[15] = Reserved for future use.  Must be zero.
   PCMD_NOZZLECOMP_OVERRIDE = 0x7A5535C8,   // Over-ride the current nozzle compensation mode for the next document.
                                            // Cmd[0] = PCMD_NOZZLECOMP_OVERRIDE
                                            // Cmd[1] = 1 (command DWORD count)
                                            // Cmd[2] = Override mode <see cref="T:Ttp.Meteor.NozzleCompOverride" />
   PCMD_CONTINUOUS_DOWNLOAD = 0x7A5535C9,   // Force download of buffered continuous print data.
                                            // Forces an immediate translation and download of any image data which is pending in PC memory for the current document, when
                                            // running in continuous print mode.
                                            // Normally, in continuous mode, image N-1 is downloaded to the hardware after image N has been processed.  When nozzle compensation is enabled,
                                            // this can be delayed until image N+1 has been received. This can lead to a delay in downloading translated image data to the hardware.
                                            // Often this does not matter, e.g. when continuous print is being used for a large image which is fully processed in advance, where the
                                            // aim is to keep buffers as full as possible.  The continuous download can be useful in situations where the print data is 
                                            // processed by the application closer to the time when it is printed.
                                            // Cmd[0] = PCMD_CONTINUOUS_DOWNLOAD
                                            // Cmd[1] = 0 (command DWORD count)
   PCMD_START_CMD_LOOP = 0x7A5535CA,   // Repeat a sequence of print commands.
                                       // All application PCMD_xxx commands received between PCMD_START_CMD_LOOP and PCMD_END_CMD_LOOP are looped through N times, the loop count
                                       // is supplied as part of the PCMD_START_CMD_LOOP command.  Nested loops are not currently supported.
                                       // These commands must reference print data which is already loaded to the hardware - i.e. for printing images from the UHS SD card, or for RAM printing mode.
                                       // This allows the loop to be carried out entirely in the hardware.
                                       // Cmd[0] = PCMD_START_CMD_LOOP
                                       // Cmd[1] = 1 (command DWORD count)
                                       // Cmd[2] = Loop count (1 or above); the total number of times the commands sent between PCMD_START_CMD_LOOP and PCMD_END_CMD_LOOP are executed
   PCMD_END_CMD_LOOP = 0x7A5535CB,   // Terminate a command loop started by PCMD_START_CMD_LOOP
                                     // Cmd[0] = PCMD_END_CMD_LOOP
                                     // Cmd[1] = 0 (command DWORD count)
   PCMD_SET_COPIES_PER_PCC = 0x7A5535CC,   // Set the number of copies of each document to print on a (master) PCC basis.  This is used for bottle printing, where some
                                           // stations may print multiple copies of the image (e.g. for undercoat or overcoat).  It also allows printing on some PCCs to be completely 
                                           // omitted from the job.  Send with zero command DWORDs to turn off per-PCC image copy mode.
                                           // Note that the document ID (if used) is generated when the notify head receives the product detect for the *first* copy of the document.
                                           // Subsequent copies do not generate document IDs.  The PrintCount increments when all copies of the document have started to print on all PCCs.
                                           // Cmd[0] = PCMD_COPIES_PER_PCC
                                           // Cmd[1] = Pcc Count (command DWORD count: 1 DWORD per PCC).  Zero resets any previously set per-PCC copy parameters.
                                           // Cmd[2 .. N] Number of image copies per (master) PCC.
   PCMD_FASTMASK = 0x7A5535CD,   // Mask an image using a given set of 4 coordinates immediately before translating.
                                 // Any image data outside of the quadrilateral will be set to white. This can be used to avoid printing ink off the edge of the media.
                                 // The 4 coordinates must form a convex quadrilateral.
                                 // Sufficient time must be given to the PrintEngine to mask and translate the image before media reaches the print heads.
                                 // Therefore it is highly recommended that you enable fast translation and parallel translation.
                                 // This command must be sent before each image command sent, if it is not and fast masking is enabled then the print will abort.
                                 // Cmd[0] = PCMD_FASTMASK
                                 // Cmd[1] = 8 (command DWORD count)
                                 // Cmd[2] = Top left coordinate X position (in px).
                                 // Cmd[3] = Top left coordinate Y position (in px).
                                 // Cmd[4] = Bottom left coordinate X position (in px).
                                 // Cmd[5] = Bottom left coordinate Y position (in px).
                                 // Cmd[6] = Bottom right coordinate X position (in px).
                                 // Cmd[7] = Bottom right coordinate Y position (in px).
                                 // Cmd[8] = Top right coordinate X position (in px).
                                 // Cmd[9] = Top right coordinate Y position (in px).
} CtrlCmdIds;

// Config parameter identifiers.
// 
// These are used to identify specific config structure parameters which
// can be adjusted by the application via the
// PiSetParam and PiSetAndValidateParam functions.
// 
// Units are shown in brackets.
typedef enum {
   CCP_FORCE_DEFAULTS = 0x00000000,   // unused
   CCP_USER_XADJUST = 0x00000001,   // X-adjust value for all images (1/100th print clock - signed)
   CCP_BIDI_XADJUST = 0x00000002,   // X-adjust for bi-directional reverse-pass in scanning mode (1/100th print clock - signed)
   CCP_HEAD_XADJUST = 0x00000003,   // Head X-adjustment (1/100th print clock - signed)
   CCP_HEAD_YADJUST = 0x00000004,   // Head Y-adjustment (pixels)
   CCP_HEAD_VOLTAGE = 0x00000005,   // Head reference voltage (Vr in 100mV steps) for voltage / temperature adjustment; zero to use default value from config file
                                    // If pcc and head are both set to zero then anum is ignored and value is applied to every head and/or nozzle row
   CCP_HEAD_TEMP_L__Obsolete = 0x00000006,   // Obsolete.  Use <see cref="F:Ttp.Meteor.eCFGPARAMEx.CPEX_RefTemp" /> for head types which support voltage / temperature adjustment.
   CCP_HEAD_GRAD__Obsolete = 0x00000007,   // Obsolete.  Use <see cref="F:Ttp.Meteor.eCFGPARAMEx.CPEX_Gradient" /> for head types which support voltage / temperature adjustment.
   CCP_HEAD_WFILE = 0x00000008,   // Deprecated.  Use CCP_HEAD_WFILE_EX.
   CCP_HEAD_XSEPARATION = 0x00000009,   // X-separation offset (1/100th print clock - signed).  Offset is applied to "Xseparation" config file setting.
   CCP_HEAD_YSEPARATION = 0x0000000A,   // Y-adjust for JA1 (pixels - signed).  Offset is applied to "Yseparation" config file setting.
   CCP_HEAD_TEMP = 0x0000000B,   // ** Legacy parameter: use CPEX_TargetTemp ** [Deprecated target head temperature (0.1C).  Set to zero to use default config file value.]
   CCP_HEAD_JA1_VOLTAGE1 = 0x0000000C,   // Fire-pulse voltage offset for 1st half of Jetting Assembly 1 (0.1 volt).  Offset is applied to "HeadVoltage" config file setting.
   CCP_HEAD_JA1_VOLTAGE2 = 0x0000000D,   // Fire-pulse voltage offset for 2nd half of JA1 (0.1 volt).  Offset is applied to "HeadVoltage" config file setting.
   CCP_HEAD_JA1_PULSEWIDTH = 0x0000000E,   // Fire-pulse width offset for JA1 (nanoseconds).  Offset is applied to "PulseWidth" config file setting.
   CCP_HEAD_JA1_RAMPUP = 0x0000000F,   // Fire-pulse ramp-up time offset for JA1 (nanoseconds).  Offset is applied to "RampUp" config file setting.
   CCP_HEAD_JA1_RAMPDN = 0x00000010,   // Fire-pulse ramp-down time offset for JA1 (nanoseconds).  Offset is applied to "RampDown" config file setting.
   CCP_HEAD_JA2_VOLTAGE1 = 0x00000011,   // Fire-pulse voltage offset for 1st half of Jetting Assembly 2 (0.1 volt).  Offset is applied to "HeadVoltage" config file setting.
   CCP_HEAD_JA2_VOLTAGE2 = 0x00000012,   // Fire-pulse voltage offset for 2nd half of JA2 (0.1 volt).  Offset is applied to "HeadVoltage" config file setting.
   CCP_HEAD_JA2_PULSEWIDTH = 0x00000013,   // Fire-pulse width offset for JA2 (nanoseconds).  Offset is applied to "PulseWidth" config file setting.
   CCP_HEAD_JA2_RAMPUP = 0x00000014,   // Fire-pulse ramp-up time for JA2 (nanoseconds).  Offset is applied to "RampUp" config file setting.
   CCP_HEAD_JA2_RAMPDN = 0x00000015,   // Fire-pulse ramp-down time offset for JA2 (nanoseconds).  Offset is applied to "RampDown" config file setting.
   CCP_SORT_TRIGGER = 0x00000016,   // Head number (1 - 8) to use as sort-trigger on this PCC.  0 for no sort-trigger.
   CCP_SORT_CONTROL = 0x00000017,   // Delay (ls 19 bits) in print clocks and pulse-width (ms 13 bits) in ms
   CCP_HSS_HEAD_VOLTAGE = 0x00000018,   // HSS head voltage (0.1 volt).  Use zero to select the default head voltage set in the config file by [Hss] HeadVoltage.
   CCP_VOFFSET = 0x00000019,   // Hss head Voffset adjustment (100mV steps)
   CCP_PTRIM = 0x0000001A,   // Hss Ptrim adjustment (10mV steps)
   CCP_PRINT_CLOCK_HZ = 0x0000001B,   // Master print clock frequency (internal encoder, Hz).  Zero for external encoder.
   CCP_USE_TRIM = 0x0000001C,   // Globally enables use of EEPROM trim voltages for HSS heads (see <see cref="T:Ttp.Meteor.eHUTSEL">eHUTSEL</see>)
   CCP_QHEAD_JA1_V_ADJ_ODD = 0x0000001D,   // Deprecated.  Use CCP_V_ADJUST_EX.
   CCP_QHEAD_JA1_V_ADJ_EVEN = 0x0000001E,   // Deprecated.  Use CCP_V_ADJUST_EX.
   CCP_QHEAD_JA2_V_ADJ_ODD = 0x0000001F,   // Deprecated.  Use CCP_V_ADJUST_EX.
   CCP_QHEAD_JA2_V_ADJ_EVEN = 0x00000020,   // Deprecated.  Use CCP_V_ADJUST_EX.
   CCP_HEAD_XOFFSET = 0x00000021,   // Head X-offset (1/100th print clock - signed)
   CCP_ENCODER_RESOLUTION = 0x00000022,   // Set the encoder multiplier (ms 16 bits) and divider (ls 16 bits)
   CCP_KHEAD_VOLTAGE = 0x00000023,   // Head voltage adjust setting. The range is +/-4V from factory setting in 0.1V increments. The setting value is multiplied by 10 so for 1.0V enter 0xA (-10 would be 0xF6)
   CCP_KHEAD_PIXELMODE = 0x00000024,   // KJ4 palette mapping (0 - 7), see user manual for details
   CCP_AUX_TEMP = 0x00000025,   // ** Legacy parameter: use CPEX_AuxTargetTemp. ** [Deprecated auxiliary temperature set point (0.1C)]
   CCP_BITS_PER_PIXEL = 0x00000026,   // Overrides default bits per pixel for current head type, if the value is supported.  
                                      // <see cref="F:Ttp.Meteor.TAppStatus.SupportedBppBitmask" /> reports the bit depths supported by the current head type.
   CCP_BIDI_HEAD_XSEPARATION_ADJUST = 0x00000027,   // Allows bi-directional setting of the JA1/JA2 X offset for scanning mode.  Units are 1/100 pixel, rounded to 1/16 pixel for printing.
   CCP_HEAD_WFILE_JA2 = 0x00000028,   // Deprecated.  Use CCP_HEAD_WFILE_EX.
   CCP_SCLK = 0x00000029,   // SCLK for HSS head (period in ns (85 - 1000), or 0 to use default)
   CCP_HEAD_ORIENTATIONS = 0x0000002A,   // Set the head orientations for the next job.  Either globally or for an individual HDC.
   CCP_FIRE_OUT = 0x0000002B,   // value Byte0 specifies GP output to strobe when the printhead fires: used to generate a signal synchronously with printhead firing. 1-4 sets GPO number, 0 disables the fire out.
                                // value Byte1 specifies GP output to strobe Exposure control:  1-4 sets GPO number, 0 Exposure control.
   CCP_STATUS_UPDATE_MS = 0x0000002C,   // Set the sleep interval which the PC uses when polling for PCC status.  The default, and maximum, is 10ms.  Larger values are ignored.
   CCP_SET_CONTINUOUS_PRINT = 0x0000002D,   // Enable/disable FIFO continuous print mode
   CCP_MONITOR_CONTINUOUS_PRINT = 0x0000002E,   // Enable/disable head monitoring for FIFO continuous printing
   CCP_KHEAD_CLK2 = 0x0000002F,   // Set KJ4 CLK2 frequency, in units of 0.1MHz, from 5MHz to 40MHz
   CCP_YSCALE__Obsolete = 0x00000030,   // Obsolete (was CCP_YSCALE)
   CCP_XSCALE__Obsolete = 0x00000031,   // Obsolete (was CCP_XSCALE)
   CCP_HEAD_TEMP2__Obsolete = 0x00000032,   // Obsolete (was CCP_HEAD_TEMP2)
   CCP_AUX_TEMP2__Obsolete = 0x00000033,   // Obsolete (was CCP_AUX_TEMP2)
   CCP_REVERSE_DIR = 0x00000034,   // Reverse transport direction in non-scanning mode
   CCP_SG1024_V_ADJ = 0x00000035,   // Deprecated.  Use CCP_V_ADJUST_EX.
   CCP_HEAD_WFILE_EX = 0x00000036,   // Index into list of waveform filenames (1 - <see cref="F:Ttp.Meteor.MeteorConsts.MAX_WAVEFORM_FNAMES">MAX_WAVEFORM_FNAMES</see>)
   CCP_XRES_SCALE = 0x00000037,   // [Most significant 16 bits | Least significant 16 bits] are either [multiplier | divider] or [0 | xdpi]
   CCP_HEAD_TEMP_MAX = 0x00000038,   // Maximum temperature for head (0.1C).  Zero means use default value.
   CCP_HEAD_PALETTE = 0x00000039,   // Palette register setting for all heads
   CCP_DRIVER_TEMP_MAX = 0x0000003A,   // Maximum temperature for head driver IC (0.1C).  Zero means use default value.
   CCP_NOZZLE_GAP = 0x0000003B,   // Nozzle gap start and end values packed (ls = start, ms = end)
   CCP_V_ADJUST_EX = 0x0000003C,   // HT_RG5: Vp in 0.1v steps; 0 to use waveform's original voltage.
                                   // HT_STARFIRE: anum = 1 - 8 to set waveform voltage scaling for SG1024 nozzle row.  Combined with "HeadVoltageAdjustment" config file setting if present. 1000 => 100% of the original voltage, 1200 => 120% of the original voltage, 800 => 80% of the original voltage
   CCP_NOZZLE_ROW_X_ADJUST = 0x0000003D,   // Signed offset in microns from the nominal row or colour separation.  Rounded to 1/16 pixel after DPI scaling.
   CCP_WFM_VSCALE_MODE__Obsolete = 0x0000003E,   // Zero: Slew time kept constant when voltage scaled.  Non-zero: Slew rate kept constant when voltage scaled.
   CCP_SCANNING = 0x0000003F,   // ** Do not use in production, this is for internal Meteor unit testing to switch between scanning mode (non-zero) and single pass mode (zero). **
   CCP_PRINT_DETECT_ENABLE__Obsolete = 0x00000040,   // Obsolete (previously available on PCC8 + HT_SPECTRA only).
   CCP_KHEAD_DSEL = 0x00000041,   // values from 0 - 3, see user manual for details
   CCP_SINGLE_NOZZLE_ROW_X_ADJUST = 0x00000042,   // Signed offset in 1/100th print clocks from the nominal row position, rounded to 1/16 pixel for printing.
   CCP_BIDI_SINGLE_NOZZLE_ROW_X_ADJUST = 0x00000043,   // Signed offset in 1/100th print clocks from the nominal row position for bi-directional reverse-pass in scanning mode, rounded to 1/16 pixel for printing.
   CCP_KHEAD_TEMP_LIMITS__Obsolete = 0x00000044,   // Obsolete.  Use CPEX_TemperatureUpperLimit and CPEX_TemperatureLowerLimit.
   CCP_K300_ABS_VOLTAGE__Obsolete = 0x00000045,   // Obsolete.  Use CPEX_HeadVoltageAbs.
   CCP_K600_ABS_VOLTAGE__Obsolete = 0x00000046,   // Obsolete.  Use CPEX_HeadVoltageAbs.
   CCP_HEAD_FIRST_ACTIVE_NOZZLE = 0x00000047,   // Offset to first active nozzle on the head.  Zero-based; i.e. offset = 0 means start at the first nozzle on the head.
   CCP_MINIMUMGAP = 0x00000048,   // Minimum gap between documents when the product detect lockout is enabled
   CCP_RESERVED1 = 0x00000049,   // Reserved for future use
   CCP_MEM_BOUNDARY = 0x0000004A,   // Boundary dword address between datapaths within head memory
   CCP_FORCE_WHITE_IMAGE = 0x0000004B,   // 1 to force all print data sent from the translator for the HDC / head / colour to be white; 0 for normal printingMust be set before image data is sent
   CCP_MERGE_ALL_IMAGES = 0x0000004C,   // Dynamic control of the MergeAllImages .cfg setting.  Can reduce overhead with a large number of small images per document.
   CCP_REDUNDANCY_MASK_IDX = 0x0000004D,   // Set the redundancy mask index to use for the next print job.  Over-rides [RedundancyMask] RedundancyMaskIdx in the config file
   CCP_TRANSLATOR_MODE = 0x0000004E,   // BIT0 set: disable fast translator;  BIT1 set: disable SIMD translator; BIT2 set: disable parallel translator
                                       // BIT3 set: disable fast stitching
   CCP_YRESDIVIDE_OFFSET = 0x0000004F,   // Nozzle offset when [Planes] YResDivider is greater than  1.  Value must be between 0 and YResDivider-1.
   CCP_SKIP_FIRE_STORE = 0x00000050,   // 0 to disable "SkipFireStore" globally, 1 to enable
   CCP_RIGHT_TO_LEFT = 0x00000051,   // Set the RightToLeft parameter.  RightToLeft is normally constant, set in the [System] config file section.
   CCP_PDOFFSET = 0x00000052,   // Sets the Product Detect offset in centi-pixels for the PCC.  N.B. Applies to both master and slave PCCs.
   CCP_PDLOCKOUT = 0x00000053,   // Enable (1) or disable (0) Product Detect Lockout.  Overrides the configuration file's [ProductDetect] Lockout.
   CCP_PCCX_TICKLEDIVIDER = 0x00000054,   // New value for [508GS] TickleDivider
   CCP_HEAD_JA1_TICKLE_VOLTAGE = 0x00000055,   // Tickle pulse voltage offset for 1st half of JA1 (0.1 volt).  Offset is applied to "TickleVoltage" config file setting.
   CCP_HEAD_JA2_TICKLE_VOLTAGE = 0x00000056,   // Tickle pulse voltage offset for 1st half of JA2 (0.1 volt).  Offset is applied to "TickleVoltage" config file setting.
   CCP_CONE_TOP_DIAMETER_UM = 0x00000057,   // Cone diameter in microns at y=0 (normally the bigger end).
   CCP_CONE_ANGLE_DEGREES_1000 = 0x00000058,   // Cone angle (half-angle) in 1/1000 of a degree  (normally +ve).
   CCP_CONE_HEIGHT_UM = 0x00000059,   // Maximum cone height used for printing in microns.
   CCP_CONE_YDPI = 0x0000005A,   // Y-axis image resolution - for cone printing.
   CCP_CONE_IMAGE_MODE = 0x0000005B,   // Image mode for cone printing. See app note for details
   CCP_SPIRAL_TOP_PRINTS_FIRST = 0x0000005C,   // 1 if top of image prints first, 0 otherwise
   CCP_SPIRAL_BAND_HEIGHT_PX = 0x0000005D,   // Print band height in pixels, for spiral printing (see app note for details)
   CCP_SPIRAL_CIRCUMFERENCE_PX = 0x0000005E,   // Cylinder circumference in pixels - for spiral printing (see app note for details)
   CCP_BYPASS_TRANSLATOR_ROW_ADJUST = 0x0000005F,   // 1: Disable all translator nozzle row X adjustments. 
                                                    // 0: Normal translator nozzle row processing.
   CCP_RAISED_EDGE_COMPENSATION = 0x00000060,   // Distance in microns
   CCP_STITCH_WIDTH = 0x00000061,   // Stitch width in pixels
   CCP_REDUCE_PRINT_DATA = 0x00000062,   // Ratio of print-lines to keep * 1e7. Input / 1e7 should be in range (0,1]. Set to 0 to disable.
   CCP_INTERNAL_0 = 0x000000F0,   // Meteor internal use.
   CCP_INTERNAL_1 = 0x000000F1,   // Meteor internal use.
   CCP_INTERNAL_2 = 0x000000F2,   // Meteor internal use.
   CCP_INTERNAL_3 = 0x000000F3,   // Meteor internal use.
   CCP_INTERNAL_4 = 0x000000F4,   // Meteor internal use.
   CCP_INTERNAL_5 = 0x000000F5,   // Meteor internal use.
   CCP_INTERNAL_6 = 0x000000F6,   // Meteor internal use.
   CCP_INTERNAL_7 = 0x000000F7,   // Meteor internal use.
   CCP_INTERNAL_8 = 0x000000F8,   // Meteor internal use.
   CCP_INTERNAL_9 = 0x000000F9,   // Meteor internal use.
   CCP_INTERNAL_A = 0x000000FA,   // Meteor internal use.
   CCP_INTERNAL_B = 0x000000FB,   // Meteor internal use.
   CCP_INTERNAL_C = 0x000000FC,   // Meteor internal use.
   CCP_INTERNAL_D = 0x000000FD,   // Meteor internal use.
   CCP_INTERNAL_E = 0x000000FE,   // Meteor internal use.
   CCP_INTERNAL_F = 0x000000FF,   // Meteor internal use.
} eCFGPARAM;

// Config parameter identifiers.
// 
// These are used to identify specific config structure parameters which
// can be adjusted by the application via PiSetParamEx
typedef enum {
   CPEX_None = 0x00000000,   // Dummy value, not a real parameter
   CPEX_X_Offset = 0x00000110,   // Absolute Nozzle Rows X offsets (in centi-pixels, 1/100 of a pixel units). Has the same meaning as "Xoffsets" parameter in Meteor config file. Use this parameter to "set" head positions.
                                 // If you want to _adjust_ head/nozzle row position relatively to the "already set" ones, use CPEX_Head_XAdjust_cpix parameter
   CPEX_Y_Offset = 0x00000111,   // Head Y offset from the configuration file. Values in pixels.
   CPEX_Y_Adjust = 0x00000112,   // Head Y adjustment
   CPEX_HeadVoltage = 0x00000113,   // Head Voltage, 1mv resolution
                                    // Head Types: HT_4CF1, HT_Xaar2001, HT_GH2220, HT_SPT_1024GS, HT_SPT_RC1536, HT_SEIKO_SRC1800
   CPEX_Gradient = 0x00000114,   // Temperature Gradient for head
                                 // Head Types: HT_4CF1, HT_TTEC_CF3, HT_TTEC_CK3, HT_SPT_1024GS, HT_SPT_RC1536
   CPEX_RefTemp = 0x00000115,   // Reference Temperature
                                // Head Types: HT_4CF1, HT_SPT_1024GS, HT_SPT_RC1536
   CPEX_TargetTemp = 0x00000116,   // Target temperature
                                   // Head Types: All currently supported head types.
   CPEX_TemperatureUpperLimit = 0x00000117,   // Head temperature upper limit for the Kyocera print heads with in-built temperature control
                                              // Printhead driver temperature threshold for the KY0360; the head is shut down if it exceeds the limit
                                              // Head Types: HT_K150, HT_K300, HT_K600, HT_K1200, HT_KY0360
   CPEX_TemperatureLowerLimit = 0x00000118,   // Head temperature lower limit for the Kyocera print heads with in-built temperature control
                                              // Head Types: HT_K150, HT_K300, HT_K600, HT_K1200
   CPEX_KProp = 0x00000119,   // Head Temperature PID Proportional element
   CPEX_KIntegral = 0x0000011A,   // Head Temperature PID Integral element
   CPEX_KDerivative = 0x0000011B,   // Head Temperature PID Derivative element
   CPEX_WF_FileIdx = 0x0000011C,   // Waveform file index.  Note: indexing starts from 1.  Negative values can be used to select built-in waveforms (HT_4CF1 only).
                                   // Head Types: HT_4CF1, HT_KM130, HT_KM_M600, HT_KM1024I, HT_KM1800I, HT_SAMBA, HT_GH2220, HT_SPT_1024GS, HT_SPT_RC1536, HT_RG4 (legacy), HT_RG5,
                                   // HT_RicohGen4, HT_RicohGen4L
   CPEX_RowX_Adj_um = 0x0000011D,   // fine X-separation adjust in microns
   CPEX_RowX_Adj_cpix = 0x0000011E,   // fine X-separation adjust in 1/100 of a pixel
   CPEX_HeadVoltageAbs = 0x0000011F,   // Head module voltage absolute setting used by Kyocera print heads with 2 (HT_K150, HT_K300) or 4 (HT_K600) drive voltage settings per head
                                       // Head Types: HT_K150, HT_K300, HT_K600
                                       // Range is 0 to 4
                                       // The value is an offset from 24v for HT_K150 or HT_K300; e.g. use a value of 1 to select a head voltage of 25v
                                       // The value is an offset from 22v for HT_K600
                                       // Also available for HT_KJ4 (4 voltages per head) for some print head models, enabled using [KJ4] UseAbsVoltages = 1
   CPEX_TickleWF_FileIdx = 0x00000120,   // Tickle waveform file index. Note: indexing starts from 1
                                         // Head Types: HT_SAMBA, HT_GH2220, HT_RG5, HT_RicohGen4, HT_RicohGen4L, HT_KM1800I, HT_KM1800I_SH, HT_KM1024I,
                                         // HT_KM1024, HT_KM1024A, HT_GMA33, HT_GMA99, HT_Xaar1201, HT_QS256, HT_PQ512, HT_SG600
   CPEX_WF_VScaleMode = 0x00000121,   // Waveform voltage scale mode 0,1,2
                                      // Head Types: HT_SAMBA, HT_GMA33, HT_GMA99, HT_KM_M600, HT_Xaar1201, HT_SG600, HT_EPSON_S3200
                                      // Zero means voltage scaling disabled
                                      // One means keep hold time constant (HT_KM_M600, HT_Xaar1201) or keep pulse width constant (Dimatix heads, HT_EPSON_S3200)
                                      // Two means keep slew rate constant
                                      // Zero is the default value for HT_KM_M600; One is the default value for HT_SG600; Two is the default value for HT_SAMBA, HT_GMA33, HT_GMA99, HT_Xaar1201
   CPEX_WF_VScaleCoeff = 0x00000122,   // Waveform voltage scale coefficient Range:[0.5 to 1.5]
                                       // Head Types: HT_SAMBA, HT_GMA33, HT_GMA99, HT_SG600, HT_KM130, HT_KM_M600, HT_KM1024I (scales VH2 only), HT_KM1800I (scales VH2 only), 
                                       // HT_KM1800I_SH (scales VH2 only), HT_KM1024 (scales VH2 only), HT_KM1024A (scales COM2 only), HT_Xaar1201, HT_RicohGen4, HT_RicohGen4L, 
                                       // HT_GH2220, HT_RicohGen5, , HT_STARFIRE, HT_PQ512, HT_QS256, HT_EPSON_S3200
   CPEX_HeadVoltageAdj = 0x00000123,   // Head voltage adjust, 1mv resolution
                                       // Head Types: HT_K1200 (1 adjustment per head), HT_K600 (1 adjustment per head), HT_K300 (2 adjustments per head), 
                                       // HT_K150 (2 adjustments per head), HT_Xaar2001 (4 adjustments per head, 1 per nozzle row),
                                       // HT_Xaar100X (2 adjustments per head, 1 per nozzle row)
   CPEX_DrivingStopFunction = 0x00000124,   // Driving Stop function control; this "terminates operation of printhead when driver IC reaches a specified temperature"
                                            // Head Types: HT_K150, HT_K300
   CPEX_WF_VH2_voltage = 0x00000125,   // WF VH2 driving voltage. KM1800I, KM1024I and KM1024 specific
                                       // Head Types: HT_KM1024I, HT_KM1800I, HT_KM1024
   CPEX_WF_VH1_A_voltage = 0x00000126,   // WF VH1 row A off-drive voltage. KM1800I, KM1024I and KM1024 specific
                                         // Head Types: HT_KM1024I, HT_KM1800I, HT_KM1024
   CPEX_WF_VH1_B_voltage = 0x00000127,   // WF VH1 row B off-drive voltage. KM1800I and KM1024I specific
                                         // Head Types: HT_KM1024I, HT_KM1800I
   CPEX_WF_VH1_C_voltage = 0x00000128,   // >WF VH1 row C off-drive voltage. KM1800I specific
                                         // Head Types: HT_KM1800I
   CPEX_Head_XAdjust_cpix = 0x00000129,   // User Nozzle row X position adjustment in 1/100 of a pixel
   CPEX_HeadOprMode = 0x0000012A,   // HDC/Head OPR mode, KM1800I and KM1024I specific
   CPEX_StitchMaskBottom = 0x0000012B,   // Index of the stitch mask file to use for the bottom of the head, where it is the upper head in a stitch band
   CPEX_StitchMaskTop = 0x0000012C,   // Index of the stitch mask file to use for the top of the head, where it is the lower head in a stitch band
   CPEX_RevScan_X_Adj_cpix = 0x0000012D,   // X Adjust value for reverse scan, in 1/100 of a pixel
   CPEX_RevScan_X_Adj_um = 0x0000012E,   // X Adjust value for reverse scan, in microns
   CPEX_NR_XSep_um = 0x0000012F,   // Nozzle rows X-separation, microns. Applicable to Ricoh RG5 heads only.  This is the distance between row 1 and 2, and between row 3 and 4.
                                   // Head Types: HT_RG5
   CPEX_JA_XSep_um = 0x00000130,   // Jetting assemblies X-separation, microns. Applicable to Ricoh RG5 heads only.  This is the distance between row 1 and 3 (and between row 2 and 4).
                                   // Head Types: HT_RG5
   CPEX_VoltageTrim0 = 0x00000131,   // Voltage Trim0, used to adjust individual ASIC voltages on HT_Xaar100X and HT_Xaar2001
   CPEX_VoltageTrim1 = 0x00000132,   // Voltage Trim1, used to adjust individual ASIC voltages on HT_Xaar100X and HT_Xaar2001
   CPEX_VoltageTrim2 = 0x00000133,   // Voltage Trim2, used to adjust individual ASIC voltages on HT_Xaar100X and HT_Xaar2001
   CPEX_VoltageTrim3 = 0x00000134,   // Voltage Trim3, used to adjust individual ASIC voltages on HT_Xaar100X and HT_Xaar2001
   CPEX_VoltageTrim4 = 0x00000135,   // Voltage Trim4, used to adjust individual ASIC voltages on HT_Xaar100X and HT_Xaar2001
   CPEX_VoltageTrim5 = 0x00000136,   // Voltage Trim5, used to adjust individual ASIC voltages on HT_Xaar100X and HT_Xaar2001
   CPEX_VoltageTrim6 = 0x00000137,   // Voltage Trim6, used to adjust individual ASIC voltages on HT_Xaar100X and HT_Xaar2001
   CPEX_VoltageTrim7 = 0x00000138,   // Voltage Trim7, used to adjust individual ASIC voltages on HT_Xaar100X and HT_Xaar2001
   CPEX_VoltageTrim8 = 0x00000139,   // Voltage Trim8, just a placeholder
   CPEX_VoltageTrim9 = 0x0000013A,   // Voltage Trim9, just a placeholder
   CPEX_VAAP = 0x0000013B,   // VAAP voltage for TTEC CF3/CK3 heads
   CPEX_VAAN = 0x0000013C,   // VAAN voltage for TTEC CF3/CK3 heads
   CPEX_WF_IdxInFile = 0x0000013D,   // WF index within whole WF file, currently for for TTEC CF3/CK3 heads
   CPEX_DroppedActiveNozzlesTop = 0x0000013E,   // Number of active nozzles at the top of the head which are not currently in use.  Changing this does not alter the Y position of the head.
   CPEX_DroppedActiveNozzlesEnd = 0x0000013F,   // Number of active nozzles at the bottom of the head which are not currently in use.
   CPEX_VDD2_1 = 0x00000140,   // VDD2_1 voltage for KY0360 head
   CPEX_VDD2_2 = 0x00000141,   // VDD2_2 voltage for KY0360 head
   CPEX_VDD2_3 = 0x00000142,   // VDD2_3 voltage for KY0360 head
   CPEX_FwdScan_X_Adj_cpix = 0x00000143,   // X Adjust value for forward scan, in 1/100 of a pixel
   CPEX_FwdScan_X_Adj_um = 0x00000144,   // X Adjust value for forward scan, in microns
   CPEX_WFLoadStatus = 0x00000145,   // A special parameter exported by PrintEngine to allow application know WF load status for given PCC:HDC:HEAD:JA. This usually happens after StartJob
   CPEX_HeadOrientation = 0x00000146,   // Head orientation. 0 for normal, 1 for inverted
   CPEX_FlagData_FileIdx = 0x00000147,   // CF3/CK3 heads flag data file index
   CPEX_HeadSubType = 0x00000148,   // Some head types have multiple variants which are similar enough that they are seen as sub-types rather than
                                    // completely different head types.
                                    // HeadSubType must be used in context with the current head type.
                                    // The PrintEngine's default value depends on the head type; sometimes the user must explicitly choose a sub-type rather than
                                    // relying on a default value.
   CPEX_PltRegVal = 0x00000149,   // Palette register value for the heads that read it from config file (4CF1)
   CPEX_Hdc_TemperatureUpperLimit = 0x0000014A,   // HDC PCB (psu/amplifiers) overtemperature limit for TTEC CF3/CK3 heads
   CPEX_AuxTargetTemp = 0x0000014B,   // Aux control target temperature
   CPEX_Heater1_IO = 0x0000014C,   // Heater1 control IO pin (mostly for Q-class heads)
   CPEX_Heater2_IO = 0x0000014D,   // Heater2 control IO pin (mostly for Q-class heads)
   CPEX_Heater3_IO = 0x0000014E,   // Heater3 control IO pin (mostly for Q-class heads)
   CPEX_Heater4_IO = 0x0000014F,   // Heater4 control IO pin (mostly for Q-class heads)
   CPEX_CalibrationMode = 0x00000150,   // Calibration Mode (used for DataLase heads)
   CPEX_PwrIntMode = 0x00000151,   // Laser Power interpolation Mode (used for DataLase heads)
   CPEX_TOnIntMode = 0x00000152,   // Laser TOn interpolation Mode (used for DataLase heads)
   CPEX_HLM_NPClk = 0x00000153,   // Xaar2001 HLM-specific setting, controls head firing
   CPEX_PaletteMode = 0x00000154,   // Seiko Rc1536 specific palette mode
   CPEX_Palette0 = 0x00000155,   // palette word0 (Seiko Rc1536 specific)
   CPEX_Palette1 = 0x00000156,   // palette word1 (Seiko Rc1536 specific)
   CPEX_RowDelay = 0x00000157,   // Some magic delay for head/HDC rows (RG5/Xaar1201 specific)
   CPEX_SabreStep = 0x00000158,   // Sabre step (HT_QS256 only)
   CPEX_VSet_DcDc1 = 0x00000159,   // KY0360_TF specific voltage parameter
   CPEX_VSet_DcDc2 = 0x0000015A,   // KY0360_TF specific voltage parameter
   CPEX_HeadVRef_U1 = 0x0000015B,   // Head U1 Ref.voltage. KY1200RM-specific
   CPEX_HeadVRef_U2 = 0x0000015C,   // Head U2 Ref.voltage KY1200RM-specific
   CPEX_HeadVScale_U1 = 0x0000015D,   // Head U1 Ref.voltage scaling coefficient. KY1200RM-specific
   CPEX_HeadVScale_U2 = 0x0000015E,   // Head U2 Ref.voltage scaling coefficient. KY1200RM-specific
   CPEX_PageSpitInterval = 0x0000015F,   // PageSpit interval. RG5-specific
   CPEX_PageSpitPixel = 0x00000160,   // PageSpit pixel. RG5-specific
   CPEX_AsicStitch_FileIdx = 0x00000161,   // EPSON_S ASIC stitching file index
   CPEX_TickleMapper1 = 0x00000162,   // Tickle Mapper value 1. KY1200RM-specific
   CPEX_TickleMapper2 = 0x00000163,   // Tickle Mapper value 2. KY1200RM-specific
   CPEX_GPIO_Disable = 0x00000164,   // GPIO-disable register value. Some obscured SII1536 feature
   CPEX_WF_VScaleCoeff_ComA = 0x00000165,   // EpsonS series specific ComA waveform scaling coefficient. Range:[0.5 to  1.5]
   CPEX_WF_VScaleCoeff_ComB = 0x00000166,   // EpsonS series specific ComB waveform scaling coefficient. Range:[0.5 to  1.5]
   CPEX_SpitGreyLevel = 0x00000167,   // Spit grey level value
   CPEX_TickleGreyLevel = 0x00000168,   // Tickle grey level value
   CPEX_AsicStitch_StartNozzle = 0x00000169,   // EPSON_S ASIC stitching start offset
   CPEX_AsicStitch_NumNozzles = 0x0000016A,   // EPSON_S ASIC stitching width
   CPEX_AsicStitch_MaskIdxTop = 0x0000016B,   // EPSON_S ASIC stitching file index for the nozzles at the top of the ASIC
   CPEX_AsicStitch_MaskIdxBottom = 0x0000016C,   // EPSON_S ASIC stitching file index for the nozzles at the bottom of the ASIC.  If zero, the "top" mask is used.
   CPEX_PixelMode = 0x0000016D,   // 'PixelMode' or palette for some of the Kyocera heads. Values: 0-7 (1bpp); 0-5 (2bpp); 0,4-5(4bpp). (HT_K150,HT_K300,HT_K600,HT_K1200,HT_KJ4)
   CPEX_DSelSignals = 0x0000016E,   // 'DSEL' signals value for some of the Kyocera heads. Values: 0-3. (HT_K150,HT_K300,HT_K600,HT_K1200,HT_KJ4)
   CPEX_SClk = 0x0000016F,   // HDC-HLM SClk period in ns
   CPEX_WorkToTickleWfScaleCoeff = 0x00000170,   // XeroxW specific scaling coefficient for making tickling WF from a working one
   CPEX_PulseWidth = 0x00000171,   // Pulse width for HT_SPECTRA
   CPEX_PulseRampUp = 0x00000172,   // Pulse ramp up time for HT_SPECTRA
   CPEX_PulseRampDown = 0x00000173,   // Pulse ramp down time for HT_SPECTRA
} eCFGPARAMEx;

// Definition of StringPool IDs.
// Each string pool stores an array of strings for various purposes, like paths to waveform files, stitching masks etc.
// Do not rely on the Ids staying the same from version to version
typedef enum {
   KSP_WaveForm_FN = 0x00000000,   // string Pool Id for storing waveform file names
   KSP_WaveForm_FN_End = 0x0000000F,   // Ids from KSP_WaveForm_FN+1 to KSP_WaveForm_FN_End are reserved for additional waveform string pools
   KSP_HdStitch_FN = 0x00000010,   // string Pool Id for storing head stitching masks file names
   KSP_SwathStitch_FN = 0x00000011,   // string Pool Id for storing swath stitching masks file names
   KSP_FixedIP = 0x00000012,   // string Pool Id for storing PCCE fixed IP addresses
   KSP_DisabledNozzles = 0x00000013,   // string Pool Id for storing lists of nozzles disabled on a particular color plane
   KSP_RedundancyMask = 0x00000014,   // string Pool Id for redundancy mask filenames or modes
   KSP_InterplaneCompensation = 0x00000015,   // string Pool Id for storing numbers of planes that can be used to compensate given plane
   KSP_FlagData_FN = 0x00000016,   // string Pool Id for CF3/CK3 flag data files (experimental feature)
   KSP_EthAdapterNames = 0x00000017,   // string Pool Id for storing Ethernet adapter names
   KSP_HHRDetails = 0x00000018,   // installation directory of the Harlequin Host Renderer RIP; empty string if HHR is not found
   KSP_AdjustColourBalance = 0x00000019,   // string Pool Id for adjusting colour balance per nozzle
   KSP_PixelFx = 0x0000001A,   // Pixel fix definitions
   KSP_ScreenProDetails = 0x0000001B,   // parent directory containing the ScreenPro screen definitions (one per sub-directory)
   KSP_FwFiles = 0x0000001C,   // Used to store some specific firmware file names
   KSP_AsicStitch_FN = 0x0000001D,   // string Pool Id for storing head ASIC stitching masks file names (mostly for Epson_S heads).
   KSP_SwGeometryMask_FN = 0x0000001E,   // string Pool Id for storing swath geometry masks file names (mostly for putting them into status report).
   KSP_ColourBalanceGradients = 0x0000001F,   // string Pool Id for storing colour balance gradients (for use in Nozzle Pattern Detection).
} eCfgStringPool;

// Return values for printer interface functions
typedef enum {
   RVAL_OK = 0x00000000,   // No errors
   RVAL_FAULT = 0x00000001,   // General error
   RVAL_EOF = 0x00000002,   // End of file
   RVAL_NOFILE = 0x00000003,   // File not found
   RVAL_BADPARAM = 0x00000004,   // Invalid parameter(s) encountered
   RVAL_BADSEQ = 0x00000005,   // Command called out of sequence.
                               // For the majority of the PrinterInterface API functions this includes the case where PiOpenPrinter has not been called.
   RVAL_EXISTS = 0x00000006,   // Printer Interface already open in the calling process.  Also returned in the case of overlapped calls to PiOpenPrinter.
   RVAL_NOTOPEN = 0x00000007,   // Printer Interface has not been opened.
                                // Often this case is considered as API commands being sent in the wrong sequence, so RVAL_BADSEQ can also indicate that the Printer Interface is not open.
   RVAL_SSFULL = 0x00000008,   
   RVAL_FULL = 0x00000009,   // Memory buffers are full. Retry command later.
   RVAL_EMPTY = 0x0000000A,   // Buffer is empty. No more messages available.
   RVAL_NOMEM = 0x0000000B,   // Out of memory
   RVAL_VERSION = 0x0000000C,   // Version mismatch.  PiOpenPrinter returns RVAL_VERSION if the Printer Interface and the Print Engine have different build numbers.
   RVAL_MISMATCH = 0x0000000D,   
   RVAL_BUSY = 0x0000000E,   // Still executing previous command. Retry command later.
   RVAL_CLOSING = 0x0000000F,   
   RVAL_NOTUSED = 0x00000010,   
   RVAL_NO_DRIVER = 0x00000011,   
   RVAL_NO_PRINTER = 0x00000012,   // Print Engine is not running
   RVAL_BAD_LICENSE = 0x00000013,   // License key specified was invalid
   RVAL_CLAIMED = 0x00000014,   // Printer Interface already open in another process
   RVAL_BADTIFFFORMAT = 0x00000015,   // Unsupported TIFF format
   RVAL_BADBITSPERPIXEL = 0x00000016,   // Incorrect bits per pixel
   RVAL_ENGINE_RUNNING = 0x00000017,   // Print engine is already running in another process
   RVAL_NOT_AVAILABLE = 0x00000018,   // Command is not available in the current configuration
   RVAL_NOT_HOSTING = 0x00000019,   // Command is only available to an application which is hosting the Meteor PrintEngine
   RVAL_UNKNOWN_TYPE = 0x0000001A,   // Unknown type (e.g. of file)
   RVAL_BAD_TYPE = 0x0000001B,   // Incorrect type (e.g. of file)
   RVAL_STRUCT_SIZE_MISMATCH = 0x0000001C,   // A structure size is incorrect.  Often the first field in a structure which is sent to the API needs to be set with the structure size in bytes.
   RVAL_MEM_LIMIT = 0x0000001D,   // The memory limit for image buffer allocation has been reached
   RVAL_REINIT = 0x0000001E,   // The command cannot be sent because the Meteor PrintEngine is (re-)initialising
   RVAL_CMD_BUF_MAPPING_FAILED = 0x0000001F,   // The command buffer cannot be mapped into process memory
   RVAL_EXCEPTION = 0x00000020,   // An exception occurred when attempting to start the PrintEngine; see Windows debug output for details
   RVAL_BADPATH = 0x00000021,   // A file path is incorrectly formatted
   RVAL_CMD_TOO_BIG = 0x00000022,   // The command is too big to fit in the PrinterInterface -> PrintEngine buffer.
                                    // The transfer buffer size can be increased using [System] CmdBufSizeDwords or [System] FlashCmdBufSizeDwords.
   RVAL_BLOCKING = 0x00000023,   // The PrinterInterface command queue is already in a blocking command in another thread
   RVAL_ABORTED = 0x00000024,   // A blocked command was aborted
   RVAL_PARAMID_NOT_REGISTERED = 0x00000025,   // An attempt to set an eCFGPARAMEx in a scope where the current head type doesn't use the parameter
   RVAL_FAILED_TO_CREATE_PROCESS = 0x00000026,   // Failed to create a sub-process (e.g. for status report creation)
   RVAL_TIMEOUT = 0x00000027,   // An operation timed out
} eRET;

// Command opcodes that a print application can send to the Meteor Monitor program
typedef enum {
   MONITOR_IDLE = 0x00000000,   // No pending command
   MONITOR_SHOW = 0x00000001,   // Show the Monitor user interface
   MONITOR_HIDE = 0x00000002,   // Hide the Monitor user interface
   MONITOR_RESET = 0x00000003,   // Reset the print engine (e.g. after a config file change)
   MONITOR_CLOSE = 0x00000004,   // Close the Monitor user interface and stop the print engine
   MONITOR_DISABLE_UI = 0x00000005,   // Disable all Monitor UI controls which can send hardware commands
   MONITOR_ENABLE_UI = 0x00000006,   // Re-enable all Monitor UI controls
   MONITOR_DISABLE_UI_ALLOW_CFG_CHANGE = 0x00000007,   // As MONITOR_DISABLE_UI but allow the configuration file to be changed and edited
   MONITOR_CLOSE_PRINTENGINE = 0x00000008,   // If Monitor is currently hosting the Print Engine, close the Print Engine but keep Monitor open
} eMONITORCMD;

// Status info regarding the Preload path
typedef struct {
   int32   DocsSent;   // Number of different documents sent to the Meteor hardware's preload datapath during the current print job.
   int32   TotalCopies;   // Total copies sent to be printed from the preload datapath during the current print job (the sum of the copy count for each preload document).
   int32   CurrentDoc_obsolete;   // Obsolete: Document number printing now on USB hardware
   int32   CopiesToGo_obsolete;   // Obsolete: Copies of this doc left to print on USB hardware
   int32   DocsToGo_obsolete;   // Obsolete: Documents left to go on USB hardware
} TPreloadPathInfo;

// Status info regarding the Fifo path
typedef struct {
   int32   DocsSent;   // Documents sent to the Meteor hardware's fifo datapath during the current print job.
} TFifoPathInfo;

// Printer state values.
// 
// Prioritised, so the printer state gets set to the highest of any of the
// PCC states. This table currently matches the
// <see cref="T:Ttp.Meteor.ePCCSTATE">PCCSTATE</see>
// table, but it may not continue to do so
typedef enum {
   MPS_DISCONNECTED = 0x00000000,   // Initial value (used by PC)
   MPS_CONNECTED = 0x00000001,   // Connected to PC
   MPS_IDLE = 0x00000002,   // Waiting for print data
   MPS_READY = 0x00000003,   // Have print data, waiting for trigger
   MPS_PRINTING = 0x00000004,   // Printing
   MPS_INITIALIZING = 0x00000005,   // Configuring FPGA
   MPS_STARTUP = 0x00000006,   // Starting up
   MPS_FAULT = 0x00000007,   // Serious fault
   MPS_LOADING = 0x00000008,   // Loading
} ePRINTERSTATE;

// Composite head power state for printer.
typedef enum {
   HPS_OFF = 0x00000000,   // HDCs and heads are off
   HPS_HDC = 0x00000001,   // At least one HDC is powered
   HPS_HEAD = 0x00000002,   // At least one head is powered
} eHEADPOWERSTATE;

// Status structure describing the state of the printer
typedef struct {
   int32   StructVersion;   // <see cref="F:Ttp.Meteor.MeteorConsts.APP_STATUS_VERSION">Structure version</see>
   int32   PeVersion;   // Print Engine version: (MAJOR_VERSION * 100) + MINOR_VERSION
   eHEADTYPE   HeadType;   // <see cref="T:Ttp.Meteor.eHEADTYPE">Head type</see>
   int32   Control;   // <see cref="T:Ttp.Meteor.Bmcontrol">Control word</see>
   int32   NumPlanes;   // Number of defined colour planes
   int32   Yinterlace_deprecated;   // This field is deprecated
   int32   PccsRequired;   // Pccs required by config file
   int32   PccsAttached;   // Number of PCCs currently attached
   ePRINTERSTATE   PrinterState;   // <see cref="T:Ttp.Meteor.ePRINTERSTATE">Overall printer state</see>
   int32   PrintSpeed;   // Print speed (print lines/second)
   int32   DocIds[64];   // List of document IDs seen at 'notify' head since last status call
   int32   DocCount;   // Doc count since last status call (i.e. number of Ids in the DocIds array)
   int32   PdCount;   // Product-detect count
   int32   PrintCount;   // Print-count in current job
   int32   Xdpi_deprecated;   // This field is deprecated
   int32   Ydpi_deprecated;   // This field is deprecated
   TPreloadPathInfo   PreloadPath;   // Preload datapath info
   TFifoPathInfo   FifoPath;   // Fifo datapath info
   eHEADPOWERSTATE   HeadPowerState;   // Overall <see cref="T:Ttp.Meteor.eHEADPOWERSTATE">head power state</see> for the printer
   int32   bmMeteorStatus;   // Additional meteor status bits BMMS_xxx <see cref="T:Ttp.Meteor.Bmms" />
   int32   PeBuildNumber;   // Print Engine build number.  
                            // This contains BUILD (low 16 bits) and REVISION (upper 16 bits) from the full version MAJOR.MINOR.BUILD.REVISION
                            // It uniquely identifies a software build.
   int32   SupportedBppBitmask;   // BitN (0-31) set if Meteor can accept N bits-per-pixel data for the current head type e.g. 0x2 means 1bpp (bit1). 0x4 means 2bpp (bit2). 0x10 means 4bpp (bit4)
   int32   BitsPerPixel;   // Currently selected bits per pixel
   int32   PrintInterval;   // Current value of the internal product detect print interval, or zero if external product detect is in use
   int32   HeadPrintLineLengthDWORDS;   // Number of DWORDs in the data for one head print line.  Varies depending on head type and selected bits per pixel.
   uint32   PCCsPresent[8];   // 256 bits array. bit set to '1' represents a connected PCC. bits indexing: [255...0]
   int32   DocsQueuedLane1;   // Number of documents queued for print lane 1; counts FIFO documents in mixed mode
   int32   DocsQueuedLane2;   // Number of documents queued for print lane 2; counts FIFO documents in mixed mode
   int32   MixedModePreloadDocsQueuedLane1;   // Number of preload documents queued for print lane 1 in mixed mode
   int32   MixedModePreloadDocsQueuedLane2;   // Number of preload documents queued for print lane 2 in mixed mode
   int32   bmDatapathsAvailable;   // Bitmask indicating datapath features available.  DATAPATH_FEATURE_FIFO, DATAPATH_FEATURE_PRELOAD etc.
   int32   DuplicatePccNumDetected;   // The difference between the number of PCCs attached and the number of different PCC numbers registered
   int32   TracerCount;   // Increments (or resets to zero) once a PCMD_TRACER command has been processed by every PCC in the system.  Ethernet hardware only.
   int32   JobCount;   // Total number of print jobs (including the active job, if any) started by the current instance of the PrintEngine.
                       // Can read zero while hardware is initialising.  Ethernet hardware only.
   int32   JobCountLane2;   // Total number of print jobs (including the active job, if any) started by the current instance of the PrintEngine on print lane 2.
                            // Can read zero while hardware is initialising.  Ethernet hardware only.
   int32   InitCount;   // Number of times the current instance of the PrintEngine has been (re-)initialised
   int32   PdCount2;   // Product-detect count 2 (aux PD input for print lane 2)
   int32   PrintCount2;   // Lane2 print-count in current job (dual lane mode only)
} TAppStatus;

// Pcc Status Structure
typedef struct {
   int32   StructVersion;   // Size of the TAppPccStatus structure in bytes.
                            // N.B. Prior to version v4.6.33054.22 this was hard-wired to APP_PCC_STATUS_VERSION (4).
   int32   IoSignals;   // I/O signal states for PCC and HDCs. Bits[31..24] represent PCC GPIO state, bits [3..0] represent HDC1 GPIO state....bits [15..12] represent HDC8 GPIO state
   int32   bmStatusBits;   // Status word from PCC, BMPS_xxx, see <see cref="T:Ttp.Meteor.Bmps">Bmps</see>
   int32   JobStatus_obsolete;   // Obsolete: previously this was the USB Job Manager status
   int32   FpgaVersion;   // Fpga Version number (unused)
   int32   FwVersion;   // Print Controller firmware version number
   int32   PdCount;   // Product-detect count
   int32   PrintCount;   // Print-count within job
   int32   FaultRegister;   // FaultRegister
   int32   AbsXCount;   // Absolute X count. Unsigned 24-bit value, so, wraps around 24 bits when increases. 
                        // In scanning mode can become negative value, which will need to be treated as 2s complement 24-bit code(I.e -1 will be presented as 2^24 -1 == 16777215)
   int32   EncoderCount;   // Encoder count
   int32   bmStatusBits2;   // Additional status bits, see  BMPS2_xxx in <see cref="T:Ttp.Meteor.Bmps">Bmps</see>
   int32   boardIdHigh;   // PCC board id high dword
   int32   boardIdLow;   // PCC board id low dword
   int32   InternalPrintClock;   // Frequency of the internal print clock, or zero when using an external encoder
   int32   StatusReadTime;   // Clock time at which this status was read from the PCC.
   int32   IntegFailErr;   // Integrity Test Fail Errors (Ethernet PCC only)
   eHEADTYPE   HeadType;   // <see cref="T:Ttp.Meteor.eHEADTYPE">Head type</see>
   int32   BitsPerPixel;   // Currently selected bits per pixel
   int32   PdCount2;   // Aux product-detect count (Ethernet hardware only)
   int32   PrintCount2;   // Document print count for lane 2 (dual-lane Ethernet configuration only)
   int32   IpV4Addr;   // PCC IpV4 address
   int32   MaxHdcs;   // The maximum number of (logical) Hdcs which the PCC supports
   int32   FpgaTimestamp_ms;   // 1ms timestamp from FPGA timer. Can be used to calculate time interval between status packets.
                               // Note that this is an unsigned 32-bit value and needs to be treated as unsigned. N.B will overflow and roll over every 49.7 days.
} TAppPccStatus;

// Some head voltage adjustments are asynchronous. This enumeration
// provides the current state of reading/writing the voltage to each head.
// Used for Kyocera head types only
typedef enum {
   VOLTAGE_INVALID = 0x00000000,   // Voltage value is not valid, e.g. when head is powered down
   VOLTAGE_READING = 0x00000001,   // A read operation is currently in progress
   VOLTAGE_READ_COMPLETE = 0x00000002,   // Voltage adjustment has been successfully read from head
   VOLTAGE_WRITE_FAILED = 0x00000003,   // Head reported a failure to write voltage adjustment
   VOLTAGE_READ_TIMEOUT = 0x00000004,   // No response from head to read commands
   VOLTAGE_READ_NOT_USED = 0x000000FF,   // The head type does not support serial read of the voltage
} eVoltageState;

// This is applicable to the K1200, K600 and K300 only. This enumeration
// provides the current state of reading/writing the waveform for each head.
// If the waveform that is programmed into the head needs to be changed, a
// new waveform can be sent to Meteor using PiSetWaveform.  It will then
// be programmed into the head the next time that the head is powered up.
typedef enum {
   WAVE_DOWNLOAD_IDLE = 0x00000000,   // A new head waveform has not been sent to Meteor for loading into the head
   WAVE_WRITE_PENDING = 0x00000001,   // Waveform will be programmed once head is powered
   WAVE_READING = 0x00000002,   // A read operation is currently in progress
   WAVE_WRITING = 0x00000003,   // A write operation is currently in progress
   WAVE_WRITE_FAILED = 0x00000004,   // Head reported a failure to write waveform
   WAVE_READ_FAILED = 0x00000005,   // Head reported a failure to read waveform
   WAVE_READ_TIMEOUT = 0x00000006,   // Timeout occurred when waiting for response to read waveform
   WAVE_WRITE_TIMEOUT = 0x00000007,   // Timeout occurred when waiting for response to write waveform
   WAVE_COMPLETE = 0x00000008,   // Waveform programming has completed sucessfully
   WAVE_NOT_USED = 0x000000FF,   // The status field is not used for the current head type
} eWaveformState;

// This is applicable to the K1200 only. This enumeration
// provides the current state of reading/writing the delay settings for each head.
// If the delay settings that are programmed into the head needs to be changed, a
// new file can be sent using PiSetUnitDelays.  It will then
// be programmed into the head the next time that the head is powered up.
typedef enum {
   DELAY_DOWNLOAD_IDLE = 0x00000000,   // New delay settings have not been sent to Meteor for loading into the head
   DELAY_WRITE_PENDING = 0x00000001,   // Delay settings will be programmed once head is powered
   DELAY_READING = 0x00000002,   // A read operation is currently in progress
   DELAY_WRITING = 0x00000003,   // A write operation is currently in progress
   DELAY_WRITE_FAILED = 0x00000004,   // Head reported a failure to write delay settings
   DELAY_READ_FAILED = 0x00000005,   // Head reported a failure to read delay settings
   DELAY_READ_TIMEOUT = 0x00000006,   // Timeout occurred when waiting for response to read delay settings
   DELAY_WRITE_TIMEOUT = 0x00000007,   // Timeout occurred when waiting for response to write delay settings
   DELAY_COMPLETE = 0x00000008,   // Delay setting programming has completed successfully
   DELAY_NOT_USED = 0x000000FF,   // The status field is not used for the current head type
} eDelaySettingState;

// This is applicable to the K1200 only. Used to specify which of the two units
typedef enum {
   U1 = 0x00000000,   // Unit 1 of print head
   U2 = 0x00000001,   // Unit 2 of print head
} eDelayUnits;

// State of the UART on the printhead
typedef enum {
   HUS_NOT_PRESENT = 0x00000000,   // No UART on this head type
   HUS_UNINITIALISED = 0x00000001,   // Head powered off, FPGA uninitialised etc.
   HUS_READY = 0x00000002,   // Ready to receive commands
   HUS_BUSY = 0x00000003,   // Still processing previous command
} eUartState;

// HDC Status Structure (legacy name TAppHeadStatus is retained for backwards compatibility). Mappings for voltage and temperature fields can be found in section 8.11 of the Software User Manual
typedef struct {
   int32   StructVersion;   // <see cref="F:Ttp.Meteor.MeteorConsts.APP_HEAD_STATUS_VERSION">Structure version</see>
   int32   PccNumber;   // PCC number (1 - n) for this record
   int32   HeadNumber;   // HDC number (1 - n) for this record (legacy name HeadNumber is retained for backwards compatibility)
   int32   bmStatusBits;   // Status word from HDC, see bit definitions BMHS_xxx
   int32   PreloadDataUsed;   // DDRAM % used of the available PCC memory on the preload path
                              // N.B. On the PCC-E in mixed mode, if the [System] MemoryBoundary is not set in advance, PreloadDataUsed reports the percentage 
                              // usage of all available memory until the job's first FIFO document is received by the PrintEngine
                              // Will read non-zero as soon as there is any print data in the preload path
   int32   FifoDataUsed;   // DDRAM % used of the available PCC memory on the FIFO path
                           // Will read non-zero as soon as there is any print data in the FIFO path
   int32   Temperature1;   // HDC temperature 1 (0.1C):
                           // Head temp HT_HSS, HT_K150, HT_K300, HT_K600, HT_K1200, HT_KJ4, 
                           // HT_SPT_508GS, HT_STARFIRE, HT_GMA33, HT_GMA99, HT_SAMBA, HT_RG5, HT_SG600, HT_KM1024A, HT_EPSON_S3200
                           // Head 1 temp for HT_KM1800I, HT_KM1024I, HT_KM1024;
                           // Head temp A for HT_SPECTRA, HT_Xaar2001;
                           // Head 1 temp A for HT_4CF1, HT_KM130, HT_KM_M600, HT_SPT_RC1536, HT_SPT_1024GS, HT_SEIKO_SRC1800;
                           // Head 1 temp A1 for HT_TTEC_CF3, HT_TTEC_CK3;
                           // Head amp temp A for HT_Xaar1201, HT_Ricoh_TH5241, HT_KY0360;
   int32   Temperature2;   // HDC temperature 2 (0.1C):
                           // Head2 temp for HT_KM1800I, HT_KM1024I, HT_KM1024;
                           // Head temp B for HT_SPECTRA, HT_Xaar2001;
                           // Head 1 temp B for HT_4CF1, HT_KM130, HT_KM_M600, HT_SPT_RC1536, HT_SPT_1024GS, HT_SEIKO_SRC1800;
                           // Head 1 temp A2 for HT_TTEC_CF3, HT_TTEC_CK3;
                           // Head amp temp for HT_GMA33, HT_GMA99;
                           // Head amp temp A for HT_SAMBA, HT_SPT_508GS; HT_SG600
                           // Head amp temp B for HT_Xaar1201, HT_Ricoh_TH5241, HT_KY0360;
                           // Head aux temp for HT_KJ4, HT_STARFIRE;
                           // Head amp temp Amp1 (low 16 bits) | Amp2 (high 16 bits) for HT_KM1024A;
                           // Head amp temp A1 (low 16 bits) | B1 (high 16 bits) for HT_EPSON_S3200;
   int32   HeadVoltage;   // Current head voltage offset for the K300, K600 and K1200. For the K300 this is split into 2 values with A-&gt;LS16bits and B-&gt;LS16bits(0.1V)
   int32   Yposition_deprecated;   // This field is deprecated. To get JA Y-position, read KPEX_Y_Offset parameter using PiGetParamEx
   int32   SabreStep_deprecated;   // This field is deprecated.
   int32   Xseparation_deprecated;   // This field is deprecated.
   int32   bmStatusBits2;   // Second status word from HDC (contents are head type specific; unused for most head types)
   int32   Temperature3;   // HDC temperature 3 (0.1C):
                           // Head2 temp A for HT_4CF1, HT_KM130, HT_KM_M600, HT_SPT_RC1536, HT_SPT_1024GS, HT_SEIKO_SRC1800;
                           // Head 1 temp B1 for HT_TTEC_CF3, HT_TTEC_CK3;
                           // Head 1 amp temp for HT_KM1024;
                           // Head amp temp A for HT_STARFIRE;
                           // Head amp temp B for HT_SAMBA, HT_SPT_508GS; HT_SG600
                           // Head amp temp C for HT_Xaar1201, HT_Ricoh_TH5241;
                           // Head amp temp Amp3 (low 16 bits) | Amp4 (high 16 bits) for HT_KM1024A;
                           // Head amp temp A2 (low 16 bits) | B2 (high 16 bits) for HT_EPSON_S3200;
   int32   Temperature4;   // HDC temperature 4 (0.1C):
                           // Head2 temp B for HT_4CF1, HT_KM130, HT_KM_M600, HT_SPT_RC1536, HT_SPT_1024GS, HT_SEIKO_SRC1800;
                           // Head 1 temp B2 for HT_TTEC_CF3, HT_TTEC_CK3;
                           // Head 2 amp temp for HT_KM1024;
                           // Head amp temp B for HT_STARFIRE;
                           // Head amp temp C for HT_SG600;
                           // Head amp temp D for HT_Xaar1201, HT_Ricoh_TH5241;
                           // Head amp temp Amp5 (low 16 bits) | Amp6 (high 16 bits) for HT_KM1024A;
                           // Head amp temp A3 (low 16 bits) | B3 (high 16 bits) for HT_EPSON_S3200;
   int32   SerialNumber;   // This field is being deprecated. Use PiGetEepromData() API to get head EEPROM information
   eVoltageState   VoltageState;   // KJ4 head voltage read/write state.  Unused for other heads.
   eUartState   UartState_deprecated;   // This field is deprecated
   int32   WaveformStatus_deprecated;   // Waveform file error status. This field is deprecated. To get WF load status, read KPEX_WFLoadStatus parameter using PiGetParamEx.
   int32   bmStatusBits3;   // Additional status bits, BMHS3_xxx
   int32   HeaterPwm;   // Up to 4 heater PWM values in bytes 0, 1, 2, 3 of the 32 bit word, depending on the head type.  Range is 0 to 255.
   int32   AbsHeadVoltage;   // Absolute HeadVoltage for the K300 and K600 heads.
                             // For K300 LS16-bits are A, MS16-bits are B.  ** Deprecated; use Voltages[0] and Voltages[1] instead **
                             // For K600 bits 0-7 U1, bits 8-15 U2, bits 16-23 U3, bits 24-31 U4.
   eWaveformState   WaveformState;   // Waveform state for the K600 and K1200. For the K300 this is the waveform state for group A
   eWaveformState   WaveformStateB;   // For the K300 only this is the waveform state for group B
   eHeadState   HeadState;   // State of the HDC and head. Can be used to determine when the head is ready to print.
   int32   StatusReadTime;   // Clock time at which this status was read from the PCC.
   int32   DdramDwordsA;   // Dwords loaded into data path A
   int32   DdramDwordsB;   // Dwords loaded into data path B
   int32   HeadDwordsA;   // Dwords printed by data path A
   int32   HeadDwordsB;   // Dwords printed by data path B
   int32   Temperature5;   // HDC temperature 5 (0.1C):
                           // Head 2 temp A1 for HT_TTEC_CF3, HT_TTEC_CK3;
                           // Head 3 temp A for HT_4CF1;
                           // Head amp temp A for HT_RG5;
                           // Head temp for HT_Xaar1201, HT_Ricoh_TH5241;
                           // Head amp temp A4 (low 16 bits) | B4 (high 16 bits) for HT_EPSON_S3200;
   int32   Temperature6;   // HDC temperature 6 (0.1C):
                           // Head 2 temp A2 for HT_TTEC_CF3, HT_TTEC_CK3;
                           // Head 3 temp B for HT_4CF1;
                           // Head amp temp B for HT_RG5;
   int32   Temperature7;   // HDC temperature 7 (0.1C):
                           // Head 2 temp B1 for HT_TTEC_CF3, HT_TTEC_CK3;
                           // Head 4 temp A for HT_4CF1;
                           // Head amp temp C for HT_RG5;
   int32   Temperature8;   // HDC temperature 8 (0.1C):
                           // Head 2 temp B2 for HT_TTEC_CF3, HT_TTEC_CK3;
                           // Head 4 temp B for HT_4CF1;
                           // Head amp temp D for HT_RG5;
   int32   Voltages[32];   // HDC voltages. Values interpretation depends on the HDC type. See the TechincalNote.zip section on the specific head type for further information
   eDelaySettingState   DelaySettingStateU1;   // Delay setting state for the K1200. This is specific for the U1 section of the print head
   eDelaySettingState   DelaySettingStateU2;   // Delay setting state for the K1200. This is specific for the U2 section of the print head
   int32   BrokenHdcStatPcktCnt;   // Number of status packets received from HDC with CRC error
   int32   BrokenPrintDataPcktCnt;   // Number of print data packets with CRC error
   int32   ImagesQueuedA;   // Count of images which have been queued to the microcontroller during the current print job (datapath A)
   int32   DocsPrintedA;   // Count of documents which have started printing (single pass) during the current print job (datapath A)
   int32   ImagesStartedA;   // Count of images which have start printing on datapath A, if [System] EnableImageTracking = 1
   int32   ImagesPrintedA;   // Count of images which have completed printing on datapath A, if [System] EnableImageTracking = 1
   int32   MiscData[32];   // Some abstract data. Interpretation depends on the HDC type. See the TechincalNote.zip section on the specific head type for further information
} TAppHeadStatus;

// Image store write status and progress.
// The image store mechanism allows preloaded image data to persist between print jobs.
// Where the image store is backed by non-volatile storage, image data persists over a hardware restart.
// The image store options are:
// --A UHS SD card fitted to each PCC.
// --PCC RAM.
// --A "virtual" Compact flash, which stores data on the PC's hard drive.
// [The 'TCompactFlashStatus' terminology derives from the Compact Flash card on the now obsolete PCC8]
typedef struct {
   int32   MaxPccNum;   // Array index of highest active PCC number that has been seen since the Meteor Print Engine started
   int32   Status[255];   // Compact flash status for each PCC
   int32   WritesQueued;   // Always zero.  Previously this was the count of queued write commands sent via PCMD_CF_WRITEFILE, which is now obsolete.
   int32   CfErrorReg[255];   // Obsolete: always zero (originally the CF card error register data value for each PCC).
   uint32   MinSizeBlocks;   // The minimum size in 512-byte blocks of all detected Compact Flash cards.  N.B. this can read zero while the cards are initialising.
   int32   SimFlash;   // Non-zero if Meteor is simulating the Compact Flash card using the local PC hard drive
   int32   DirectDdramAccess;   // Non-zero if the PCMD_CF_xxx commands are being routed to preload RAM rather than the UHS SD card (PCCE only)
   uint32   CfTranslateDocumentRxCount;   // Total number of documents received for processing via PCMD_CF_TRANSLATEIMAGE then PCMD_CF_STOREIMAGE; incremented as soon as the document's first PCMD_CF_TRANSLATEIMAGE command is received
   uint32   CfTranslateProcessedPercent;   // Percentage of the most recent PCMD_CF_TRANSLATEIMAGE/PCMD_CF_STOREIMAGE document which has been translated; the PrintEngine expects to receive one PCMD_CF_TRANSLATEIMAGE command per plane
   uint32   CfStoreImageLoadedPercent;   // Percentage of the most recent PCMD_CF_TRANSLATEIMAGE/PCMD_CF_STOREIMAGE document which has been loaded to the image store; the load is started by the PCMD_CF_STOREIMAGE call
} TCompactFlashStatus;

// Continuous print status structure
typedef struct {
   int32   MinBufferedDWORDs;   // The minimum amount of buffered data over all heads selected for continuous print monitoring
   int32   MinBufferedPercent;   // The above expressed as percentage of available head memory on the PCC card
   int32   StateFlags;   // Continuous print state over all selected heads.
   int32   HeadWidthDwords;   // The number of DWORDS in a buffered print line
} TContinuousPrintStatus;

// Head EEPROM data represented in generic format (JSON)
typedef struct {
   char   JsonText[4096];   // JSON text string
} TGenericEepromData;

// Structure to store serial number data read back from the security chip fitted to some Head Driver Card types
typedef struct {
   int32   DataReady;   // Flag set if the security chip data has been read.  If FALSE the Meteor Print Engine is
                        // still reading data from the head and the application should try again later.
   int32   StatusBits;   // HDC serial number status bits.  Top bit (BIT31) is set for HDCs which do not support a software serial number.
                         // All other bits should be ignored by the application.
   uint8   SerialNumber[9];   // HDC serial number
} SerialNumberStatus;

// Meteor status fields required for Drop Tuner
typedef struct {
   int32   StructVersion;   // Structure version number
   int32   HssAsicCentiVolts[16];   // Voltage (x100) applied to HSS ASIC. Legacy Parameter.
   int32   HssAsicTrimCentiVolts[16];   // PrintEngine component of HSS ASIC trim voltage (x100). Legacy Parameter.
   int32   LeopardVr;   // Leopard Vr head setting
   int32   LeopardTr;   // Leopard Tr head setting
   int32   LeopardG;   // Leopard G head setting
   int32   SpectraJa1V1;   // Spectra V1 for JA1
   int32   SpectraJa1V2;   // Spectra V2 for JA1
   int32   SpectraJa1RampUp;   // Spectra ramp up time (us) for JA1
   int32   SpectraJa1Pulse;   // Spectra pulse width time (us) for JA1
   int32   SpectraJa1RampDown;   // Spectra ramp down time (us) for JA1
   int32   SpectraJa2V1;   // Spectra V1 for JA2
   int32   SpectraJa2V2;   // Spectra V2 for JA2
   int32   SpectraJa2RampUp;   // Spectra ramp up time (us) for JA2
   int32   SpectraJa2Pulse;   // Spectra pulse width time (us) for JA2
   int32   SpectraJa2RampDown;   // Spectra ramp down time (us) for JA2
   int32   DefSpectraJa1V1;   // Spectra V1 for JA1
   int32   DefSpectraJa1V2;   // Spectra V2 for JA1
   int32   DefSpectraJa1RampUp;   // Spectra ramp up time (us) for JA1
   int32   DefSpectraJa1Pulse;   // Spectra pulse width time (us) for JA1
   int32   DefSpectraJa1RampDown;   // Spectra ramp down time (us) for JA1
   int32   DefSpectraJa2V1;   // Spectra V1 for JA2
   int32   DefSpectraJa2V2;   // Spectra V2 for JA2
   int32   DefSpectraJa2RampUp;   // Spectra ramp up time (us) for JA2
   int32   DefSpectraJa2Pulse;   // Spectra pulse width time (us) for JA2
   int32   DefSpectraJa2RampDown;   // Spectra ramp down time (us) for JA2
   int32   QClassJA1OddPiezoVoltageAdjust;   // Voltage adjust for odd piezos on JA1
   int32   QClassJA1EvenPiezoVoltageAdjust;   // Voltage adjust for even piezos on JA1
   int32   KClassHeadTemperature;   // KJ4 current head temperature
   int32   KClassAuxTemperature;   // KJ4 current auxiliary temperature
   int32   KClassHeadTempLimit;   // KJ4 head temperature limit
   int32   KClassAuxTempLimit;   // KJ4 auxiliary temperature limit
   int32   CF1_JA1_Vr;   // CF1 JA1 Vr head setting
   int32   CF1_JA2_Vr;   // CF1 JA2 Vr head setting
   int32   CF1_JA1_Tr;   // CF1 JA1 Tr head setting
   int32   CF1_JA2_Tr;   // CF1 JA2 Tr head setting
   int32   CF1_JA1_G;   // CF1 JA1 G head setting
   int32   CF1_JA2_G;   // CF1 JA2 G head setting
   int32   SptTemperatureReference;   // Seiko Printek temperature control reference (Tr)
   int32   SptTemperatureGradient;   // Seiko Printek temperature control gradient (G)
   int32   SptTargetPztTemperature;   // Seiko Printek target THM1/PZT temperature
   int32   SptCurrentPztTemperature;   // Seiko Printek current THM1/PZT temperature
   int32   SptMaxPztTemperature;   // Seiko Printek maximum THM1/PZT temperature
   int32   SptPalette;   // Seiko Printek palette register value
   int32   SptVdd2;   // Seiko Printek Vdd2 voltage for entire head or row A
   int32   SptCurrentDriverTemperature;   // Seiko Printek current THM2/driver temperature
   int32   SptMaxDriverTemperature;   // Seiko Printek maximum THM2/driver temperature
   int32   SptVdd2B;   // Seiko Printek Vdd2 voltage for 508GS row B
   int32   SptCurrentDriverTemperatureB;   // Seiko Printek current THM2b driver temperature for 508GS
   int32   SptVdd2C;   // Seiko Printek Vdd2 voltage for 1024 or 1536 row C
   int32   SptVdd2D;   // Seiko Printek Vdd2 voltage for 1024 or 1536 row D
   int32   SptCurrentPztTemperatureCD;   // Seiko Printek current PZT temperature for Row C and D (1024 only)
   char   checkString[4];   // Marshaling check string should be "TTP"
} TDropTunerStatus;

// Details of the location of each colour plane as defined in the Meteor configuration file
// The lookup Arrays are zero indexed - i.e. the details of "plane 1" are at index 0 in each array etc.
// FirstNozzlePos[N] and LastNozzlePos[N] are both zero if plane N is not in use
typedef struct {
   int32   FirstNozzlePos[32];   // Position of the first active nozzle in each colour plane
   int32   LastNozzlePos[32];   // Position **one nozzle after** the last active nozzle in each colour plane; the number of nozzles in use for plane N is LastNozzlePos[N] - FirstNozzlePos[N]
   int32   BitsPerPixel[32];   // Bit depth for print data sent to the plane.  Normally the same for each plane.  
                               // When running with multiple subsystems (e.g. with mixed head types), planes in different subsystems can use different bit depths.
   int32   HeadCount[32];   // Number of heads which are assigned to the plane
   int32   PrintLaneIndex[32];   // Print lane (1 or 2) which the plane is assigned to
   int32   UsedPlaneCount;   // The number of populated planes.  These are not necessarily contiguous.
   int32   UsedLaneCount;   // The number of independent print lanes in use.
} MeteorPlaneConfig;

// For future use.  Determines how pixels are decoded from a multi-channel file into a Meteor image buffer.
typedef enum {
   REVERSE_BYTES_32 = 0x00000000,   // Reverse the byte order of each 32 bit DWORD.  The bit order within each byte is unchanged.
} FilePixelDecodeMode;

// Bits for the flags field in PiAllocateTiffImageBuffer
typedef enum {
   TIFF_BPP_ANY = 0x00000001,   // Set: Load the image regardless of the current Meteor bits-per-pixel value, provided the image is at 1,2 or 4 bits-per-pixel
                                // Clear: An attempt to load an image with a bits-per-pixel resolution which does not match Meteor's current setting will fail.
                                // A one bit per pixel file can however be loaded at 2 or 4 bits per pixel if the <see cref="F:Ttp.Meteor.bmImageLoadFlags.IMG_LOAD_EXPAND" /> 
                                // flag is set in the <see cref="T:Ttp.Meteor.ImageLoadDetails" />
} bmTIFFLoadFlags;

// Holds details of a TIFF file which has been loaded into a Meteor image buffer; can also be used for BMP files
typedef struct {
   uint32   StructureSizeBytes;   // [In] Size of the TIFFImageDetails structure in bytes.  Must be filled in by the user
   uint32   WidthPixels;   // [Out] Full width of the image file in pixels (the image buffer the file is loaded to may be smaller, due to cropping)
   uint32   HeightPixels;   // [Out] Full height of the image file in pixels (the image buffer the file is loaded to may be smaller, due to cropping)
   uint32   ImageBufferID;   // [Out] Allocated buffer index, or [In] image buffer index for use with <see cref="F:Ttp.Meteor.bmImageLoadFlags.IMG_LOAD_COMBINE_BUFFER" />
   uint32   FileBpp;   // [Out] Bits per pixel of the image data in the TIFF file.  Note that the underlying TIFF file could report a higher bpp value, 
                       // because there could be unused bits in each pixel (e.g. an indexed 8bpp TIFF which only has 3 grey levels in its colour
                       // map is reported here as FileBpp = 2)
   uint32   JobID;   // [In] Optional job ID tag for the image buffer.  If non zero, any remaining buffers are automatically freed if a job with a matching ID is aborted.
   uint32   PrintingBpp;   // [Out] Bits per pixel of the printing data; this is normally the same as FileBpp for files which have already been screened
} TIFFImageDetails;

// Parameters which are sent to PiAllocateImageBufferEx
typedef struct {
   uint32   StructureSizeBytes;   // [In] Size of the ImageBufferAllocParams structure in bytes.  Must be filled in by the user.
   uint32   ImageBufferID;   // [Out] Allocated buffer index, or 0xFFFFFFFF (<see cref="F:Ttp.Meteor.MeteorConsts.IMG_BUF_UNSET" /> if memory allocation fails or 
                             // if the application is not hosting the PrintEngine
   uint32   SizeDwords;   // [In] Requested buffer size in Dwords.  Note that the buffer stride must be a multiple of Dwords.
   uint32   BitsPerPixel;   // [In] Bit depth of the raster data which will be written to the buffer.  Zero means the current global bit depth will be used.
   uint32   WidthPixels;   // [In] Width of the buffer in pixels (N.B. not including any padding pixels at the end of each line)
   uint32   HeightPixels;   // [In] Height of the buffer in pixels
} ImageBufferAllocParams;

// Holds details of how multi-channel print data is arranged in a file.  It is the application's responsibility to decode the details 
// of the file header and fill in the structure details.
// This is suitable for files which:
// - contain data at a resolution of 1,2 or 4 bits per pixel
// - interleave data for multiple planes on a print-line by print-line basis
// - pad print data at the end of each print line to a byte boundary
typedef struct {
   int32   StructureSizeBytes;   // Size of the MultichannelFileDetails structure in bytes.  Must be filled in by the user
   int32   WidthPixels;   // Width in pixels of the image in the file
   int32   HeightPixels;   // Height in pixels of the image in the file
   int32   BitPerPixel;   // Resolution of the print data.  Must be 1,2 or 4
   int32   FileDataOffset;   // Offset in bytes from the start of the file to the data
   int32   FileBytesPerLine;   // Number of bytes per print line for one channel (plane).  Includes any padding after the end of the line data
   int32   FilePlaneCount;   // Number of channels (planes) of data contained in the file
   FilePixelDecodeMode   DecodeMode;   // For future use: currently ignored.
} MultichannelFileDetails;

// Formatting details for adding a QR code into an image buffer
typedef struct {
   uint32   StructureSizeBytes;   // [In] Size of the QrCodeDetails structure in bytes.  Must be filled in by the user
   uint32   ImageBufferID;   // [Out] Allocated buffer index
                             // [In] image buffer index for use with <see cref="F:Ttp.Meteor.bmImageLoadFlags.IMG_LOAD_COMBINE_BUFFER" />
   uint32   BitsPerPixel;   // [In] Bit depth (1,2 or 4 bits per pixel)
   uint32   GreyLevel;   // [In] Grey level to use
   uint32   WidthPixels;   // [In] Width in pixels.  May be different to HeightPixels if the X and Y DPI are different.
   uint32   HeightPixels;   // [In] Height in pixels.  May be different to WidthPixels if the X and Y DPI are different.
   uint32   BorderModules;   // [In/Out] Border size in QR code modules; minimum size is 4
   uint32   ErrorCorrectionLevel;   // [In/Out] QR error correction level (0-3)
   uint32   Flags;   // Valid flags are <see cref="F:Ttp.Meteor.bmImageLoadFlags.IMG_LOAD_DRAW_BORDER" /> and <see cref="F:Ttp.Meteor.bmImageLoadFlags.IMG_LOAD_COMBINE_BUFFER" />
   int32   BufferXPos;   // [In] X position within the buffer - only used if <see cref="F:Ttp.Meteor.bmImageLoadFlags.IMG_LOAD_COMBINE_BUFFER" /> is set in Flags
   int32   BufferYPos;   // [In] Y position within the buffer - only used if <see cref="F:Ttp.Meteor.bmImageLoadFlags.IMG_LOAD_COMBINE_BUFFER" /> is set in Flags
} QrCodeDetails;

// Formatting details for generating a watermark buffer from a given job.
typedef struct {
   uint32   StructureSizeBytes;   // [In] Size of the WatermarkDetails structure in bytes. Must be filled in by the user
   uint32   JobSetId;   // [In] The Job Set ID to watermark
   uint32   JobId;   // [In] The Job ID to watermark. If larger than number of jobs, we'll use JobId % NumJobs
   uint32   PositionId;   // [In] The Position Id to watermark. If final position, <see cref="F:Ttp.Meteor.eRET.RVAL_EOF" /> is returned by PiGenerateWatermark()
   bool   FreeBuffers;   // [In] Set to true to free the watermark buffers for the given <see cref="F:Ttp.Meteor.WatermarkDetails.JobSetId" />
   char   Content[33];   // [In/Out] The data in the watermark to uniquely identify it, always a string with 32 characters + '\0'.
                         // If it is set to "" after returning then the next position requires a new content.
   uint32   ImageBufferIdsOut[32];   // [Out] Image buffer indexes that have been watermarked, per plane
   uint32   XPosOut[32];   // [Out] The x-position to print the watermark at, per plane
   int32   YPosOut[32];   // [Out] The y-position to print the watermark at, per plane
   uint32   Width[32];   // [Out] The width of the watermark, per plane
} WatermarkDetails;

#define ImgDetailsRgbTiff 0x00000001   // The file is an RGB TIFF (i.e. it needs RIPPing before it can be printed)
#define ImgDetailsStitchOverride 0x00000002   // The file contains data to print each stitch-band separately, overriding the normal stitch settings.
                                              // It is a custom test pattern generated by Meteor.

// Generic description of an image file
typedef struct {
   uint32   Width;   // Width in pixels of the image in the file
   uint32   Height;   // Height in pixels of the image in the file
   uint32   BitsPerSample;   // Resolution of each pixel of print data
   uint32   SamplesPerPixel;   // Number of channels of data in the file
   uint32   XDpi;   // X resolution in dots-per-inch
   uint32   YDpi;   // Y resolution in dots-per-inch
   uint32   Flags;   // Bit fields defined in <see cref="T:Ttp.Meteor.bmImageDetailsFlags" />
} GenericImageFileDetails;

// Bits which can be set in the Flags field of<see cref="T:Ttp.Meteor.ImageLoadDetails" />
typedef enum {
   IMG_LOAD_CROP = 0x00000001,   // Should the image be cropped according to the structure's crop values
   IMG_LOAD_EXPAND = 0x00000002,   // Should a 1 bit-per-pixel image be expanded to 2 or 4 bits-per-pixel using the <see cref="F:Ttp.Meteor.ImageLoadDetails.OneBppMapMode" /> gray level
   IMG_LOAD_XMIRROR = 0x00000004,   // Mirror the image in X
   IMG_LOAD_YMIRROR = 0x00000008,   // Mirror the image in Y
   IMG_LOAD_EXTEND_BUFFER = 0x00000010,   // Position the (cropped) image at an X,Y position within a new, larger, image buffer
   IMG_LOAD_COMBINE_BUFFER = 0x00000020,   // Position the (cropped) image at an X,Y position within an existing buffer.
                                           // Pixels outside the bounds of the new image are unchanged; existing pixel data within the new image bounds is replaced.
   IMG_LOAD_X_REPEAT = 0x00000040,   // Repeat image in X
   IMG_LOAD_DRAW_BORDER = 0x00000080,   // Draw a one pixel border around the border of a QR code buffer; this can be useful for debugging
   IMG_LOAD_SCREEN_IN_PLACE = 0x00000100,   // When loading and screening a contone image, place the screened data into the same buffer which the file is first loaded into, 
                                            // rather than into a second (smaller) buffer sized for the half-tone data (after which the original buffer is released).  
                                            // This can be potentially wasteful of memory, because the resulting buffer is sized for contone data, so is only 1/8 or 1/4
                                            // used.  But it can also have benefits in low memory situations, because the total amount of memory used during the load and
                                            // screen is reduced.
   IMG_LOAD_REUSE_BUFFER = 0x00000200,   // Re-use an existing image buffer, resetting the details if necessary.  The existing buffer must be at least as large
                                         // as the required size for the new image.
   IMG_LOAD_ROTATE = 0x00000400,   // Should the image be rotated according to the ImageLoadDetails structure's rotation values (PiCopyImageBuffers only)
} bmImageLoadFlags;

// Structure holding information details which can be supplied when loading a file into
// a Meteor image buffer.  Used by PiAllocateTiffImageBuffer and PiAllocateMultichannelFileBuffers
typedef struct {
   int32   StructureSizeBytes;   // [In] Size of the ImageLoadDetails structure in bytes.  Must be filled in by the user.  
                                 // Used to protect against version inconsistencies.
   int32   Flags;   // [In] Bits controlling which details are used.  See <see cref="T:Ttp.Meteor.bmImageLoadFlags" />
   int32   CropXStart;   // [In] X position to start cropping the image - only used if IMG_LOAD_CROP is set in Flags
   int32   CropYStart;   // [In] Y position to start cropping the image - only used if IMG_LOAD_CROP is set in Flags
   int32   CropWidth;   // [In/Out] Width of the cropped image (if IMG_LOAD_CROP is set in Flags)
   int32   CropHeight;   // [In/Out] Height of the cropped image (if IMG_LOAD_CROP is set in Flags)
   int32   OneBppMapMode;   // [In] Gray level to use when expanding a one bit per pixel file to two or four bits per pixel (if IMG_LOAD_EXPAND is set in Flags)
   int32   BufferWidth;   // [In] Buffer width if the buffer is created larger than the (cropped) image - 
                          // only used if IMG_LOAD_EXTEND_BUFFER or IMG_LOAD_COMBINE_BUFFER or IMG_LOAD_X_REPEAT is set in Flags
   int32   BufferHeight;   // [In] Buffer height if the buffer is created larger than the (cropped) image - 
                           // only used if IMG_LOAD_EXTEND_BUFFER or IMG_LOAD_COMBINE_BUFFER is set in Flags
   int32   BufferXPos;   // [In] X position within the buffer - only used if IMG_LOAD_EXTEND_BUFFER or IMG_LOAD_COMBINE_BUFFER is set in Flags
   int32   BufferYPos;   // [In] Y position within the buffer - only used if IMG_LOAD_EXTEND_BUFFER or IMG_LOAD_COMBINE_BUFFER is set in Flags
   int32   ImageXRepeat;   // [In] Repeat image in X after loading - only used if IMG_LOAD_X_REPEAT is set in Flags.
                           // Exactly 'ImageXRepeat' copies of the image are written to the image buffer.  'ImageXRepeat' must be 1 or more.
   int32   ImageXRepeatGap;   // [In] Gap (pixels) between repeated X images - 
                              // only used if <see cref="F:Ttp.Meteor.ImageLoadDetails.ImageXRepeat" /> is more than 1 and IMG_LOAD_X_REPEAT is set in Flags
   int32   ColourPlaneIndex;   // [In] Index of the colour plane the file will be printed on (1-N).  
                               // Required if the buffer needs screening or in a mixed head type system.  Can be zero otherwise.
   int32   PrinterYPos;   // [In] Y position that the first line in the image buffer will be printed at.  Required if the buffer needs screening.
   int32   FileChannelIndex;   // [In] Index of the channel within the TIFF file (0 to SamplesPerPixel-1).  Used for multi-channel TIFF files only.
   int32   ScreenModeIndex;   // [In] Index of the ScreenPro mode to use, if screening is required (i.e. if the file contains 8bpp or 16bpp print data)
                              // The screen modes available are listed in the [ScreenModeN] sections of the Meteor configuration file
                              // Zero selects the default screening mode
   int32   RotateDegrees;   // [In] The degrees that the image will be rotated by (PiCopyImageBuffers only).
                            // Can be 90 or 270 - only used if IMG_LOAD_ROTATE is set in Flags.
   int32   Directory;   // [In] TIFF files can have multiple images in multiple directories, they are labelled sequentially from 0. 
                        // Most TIFF files only have one directory. We only load the image from a single directory specified here. 
                        // The default directory is 0.
} ImageLoadDetails;

// [In/Out] Parameters for the PiRipFile method, which RIPs a PDF / RBG Tiff into a set of PrintEngine image buffers
typedef struct {
   int32   StructureSizeBytes;   // [IN] Size of the RipDetails structure in bytes.  Must be filled in by the user.  
                                 // Used to protect against version inconsistencies.
   char   RipConfigName[256];   // [IN] Name of the RIP configuration (in the SW\TestConfig directory) to use.  An empty string selects a default in-built mode
                                // or the RIP configuration specified in the Meteor configuration file by [HHR] DefaultConfig, if present.
   int32   PlaneMask;   // [IN] BIT0 set to load plane 0 etc., or set to zero to fill image buffers for all planes which are RIPPed
   uint32   ImgBufferIndexes[32];   // [OUT] filled in with the Meteor buffer indexes for the RIPPed channels.  IMG_BUF_UNSET (0xFFFFFFFF) for channels which don't exist.
   int32   RasterWidthPx;   // [OUT] Width in pixels of the resulting raster image
   int32   RasterHeightPx;   // [OUT] Height in pixels of the resulting raster image (prior to any cropping)
   int32   Mirror;   // [IN] Override's the RIP mode's mirror setting
   int32   Orientation;   // [IN] Override's the RIP mode's rotation in multiples of 90 degrees
   int32   FirstPage;   // [IN] First page of a multi-page PDF to RIP; 0 for all pages or if the file is not a multi-page document
   int32   LastPage;   // [IN] Last page of a multi-page PDF to RIP; 0 for all pages or if the file is not a multi-page document
   int32   ControlFlags;   // [IN] BIT0 if further calls for the same file are expected; BIT1 to get the next page from a previously started RIP; 
                           // BIT2 to abort a running RIP; BIT3 for double sided mode
   int32   FirstAltPlane;   // [IN] Index (zero based) of the first plane for the alternate pages in double sided mode
   int32   OneBppMapMode;   // [In] A one bit-per-pixel RIP config can be used to generate a raster image for printing at two or four bits-per-pixel
                            // In this case, OneBppMapMode is the grey level used for all non-zero pixels
   bool   UseLegacyMode;   // [IN] N.B Allows the user to select to use the old version of the Inline RIP for compatibility.
                           // Enable this option will disable the option of running with scalable RIP but for users that don't need it will improve backward compatibility
   int32   BufferCount;   // [IN] The amount of channel buffers that will be created and filled before the RIP is stalled.
                          // This value is multiplied by the amount of scalable threads that is used (if using scalable otherwise just uses the number)
                          // It is advised for smaller files to use more and larger files less.
   bool   ScalableRip;   // [IN] N.B Enables scalable RIP mode allowing for multiple threads to be use to RIP the files.
                         // Testing suggests that you need to keep the CPU usage below 100% otherwise this will not be a big performance increase
   uint32   ScalableThreads;   // [IN] The number of threads used in scalable mode
   uint32   ScalableMemory;   // [IN] The amount of memory that the RIP can use while in scalable mode. This is in MB
                              // This is divided evenly between the the RIPs eg. 4 RIPs with 16000 Memory will give 4000 to each
} RipDetails;

// In/Out parameters for PiRipPreview
typedef struct {
   int32   StructureSizeBytes;   // [In] Size of the RipPreviewDetails structure in bytes.  Must be filled in by the user.
                                 // Protects against version inconsistencies.
   char   PreviewFilename[256];   // [Out] Full path to the generated preview file.  The preview is written to the same directory as the input file.
   char   PreviewConfig[256];   // [In] Optional RIP configuration file, which should be in the RIP's TestConfig directory.
                                // Use "" to select the PrintEngine's default preview mode.
   int32   Page;   // [In] If non-zero, selects the preview page in a multi-page PDF when using the automatic preview mode
   int32   Dpi;   // [In] If non-zero, selects the DPI which the automatic preview mode uses.  The default (if zero) is 96.
} RipPreviewDetails;

#define PXCOUNT_MAX_GREYLEVELS 0x00000010   // Size of the <see cref="F:Ttp.Meteor.ImagePixelDetails.PixelCount" /> array

// Structure holding the count of pixels at each grey level for an image
typedef struct {
   int32   StructureSizeBytes;   // [In] Size of the ImagePixelDetails structure in bytes.  Must be filled in by the user.  
                                 // Used to protect against version inconsistencies.
   uint64   PixelCount[16];   // [Out] Pixel count at each grey level; the number of populated values depends on the image's bit depth
   bool   FreeImageBuffer;   // Free the buffer after the pixel count has completed (e.g. if the buffer won't be subsequently printed)
} ImagePixelDetails;

// Structure holding the details needed to attach a spit-bar to an image buffer
// 
// The total buffer size needed is <see cref="F:Ttp.Meteor.AttachSpitBarDetails.OriginalImageWidthPx" /> + <see cref="F:Ttp.Meteor.AttachSpitBarDetails.AlternateEndingOffsetPx" /> + <see cref="F:Ttp.Meteor.AttachSpitBarDetails.AlignmentEndWidthPx" />
typedef struct {
   int32   StructureSizeBytes;   // [In] Size of the AttachSpitBarDetails structure in bytes.  Must be filled in by the user.  
                                 // Used to protect against version inconsistencies.
   int32   OriginalImageWidthPx;   // [In] Unadjusted width of the original image.
   int32   AlignmentEndWidthPx;   // [In] Number of lines of the end of the image that need to be included in the alternate ending
                                  // This is so that the jump from the common part of the image to the alternate ending lies on an image store block boundary
   int32   TranslatorEndWidthPx;   // [In] Width of the image that needs to be translated twice.  Goes at the very end (or start) of the image buffer
                                   // This will normally be at least the HDC X span in size plus OriginalImageWidthPx, though it's also guaranteed to be never larger
                                   // than OriginalImageWidthPx (and can be equal for very short images)
                                   // It is so that the translator creates a second copy of the final part of the image in the alternate image end
   int32   AlternateEndingOffsetPx;   // [In] The number of pixels between the two versions of the image end.  All data from the end of the spit bar itself to this point must be zero.
                                      // This includes space for the 'HDC X span' between the two versions of the image end, so that after translation, the print 
                                      // of the two endings doesn't overlap.
                                      // The HDC X span includes the head nozzle row separation, and the distance between heads for multi-head HDCs
   int32   SpitBarOffsetPx;   // [In] The distance in pixels between the end of the image and the spit-bar
   int32   SpitBarWidthPx;   // [In] The width of the spit-bar in pixels
   int32   ColourPlaneId;   // The index of the Meteor colour plane which will be printing the spit bar (1-N)
} AttachSpitBarDetails;

// Defines extended parameters sent to the PiSendCommandEx API method
typedef struct {
   int32   StructureSizeBytes;   // Size of the CommandExParamsstructure in bytes.  Must be filled in by the user.
   int32   Lane;   // Lane (1-N) the command is sent to.  Lanes are defined in the configuration file
} CommandExParams;

// Status structure describing the basic printer layout as defined in the
// current Meteor configuration file.  The values returned in this structure 
// do not change unless the Meteor configuration file is changed.
typedef struct {
   eHEADTYPE   HeadType;   // <see cref="T:Ttp.Meteor.eHEADTYPE">Head type</see>
   int32   BaseXDpi;   // Base X resolution defined by the configuration file in Dots Per Inch
   int32   XResDividerHigh;   // X resolution divider used for printing at normal (high) resolution <see cref="F:Ttp.Meteor.eRES.RES_HIGH" />; normally this is set to 1
   int32   XResDividerMed;   // X resolution divider used for printing at medium resolution <see cref="F:Ttp.Meteor.eRES.RES_MED" />
   int32   XResDividerLow;   // X resolution divider used for printing at low resolution <see cref="F:Ttp.Meteor.eRES.RES_LOW" />
   int32   YDpi;   // Y resolution defined by the configuration file in Dots Per Inch.  Derived from the print head's native resolution and the configured Y interlace (if set); assumes sabre angles are not being used.
   int32   YSpanPixels;   // The maximum Y span of an image; this is the minimum Y span over all configured planes.  Normally, all planes should have the same Y span.
                          // More information can be found via <see cref="T:Ttp.Meteor.MeteorPlaneConfig" />
                          // Does not take into account planes with extended plane indexes greater than 32 (<see cref="F:Ttp.Meteor.MeteorConsts.MAX_PLANES" />)
   bool   bSupports1BppPrintData;   // Does the current head type support one bit per pixel print data
   bool   bSupports2BppPrintData;   // Does the current head type support two bits per pixel print data
   bool   bSupports4BppPrintData;   // Does the current head type support three bits per pixel print data.  N.B. the print data sent to Meteor must be padded to four bits per pixel; the most significant bit is ignored.
} TCurrentCfgDesc;

// Enumeration of the printable image file formats handled by the MetPrint and MetScan applications
typedef enum {
   eUNKNOWN_FILE = 0x00000000,   // File format is not recognised
   eTIF_FILE = 0x00000001,   // TIFF file
   ePRT_FILE = 0x00000002,   // PRT file type 1 (.PRT is generally an application specific file type)
   ePRT2_FILE = 0x00000003,   // PRT file type 2 (.PRT is generally an application specific file type)
   eRTZ_FILE = 0x00000004,   // RTZ file
   ePRT3_FILE = 0x00000005,   // PRT file type 3 (.PRT is generally an application specific file type)
   ePDF_FILE = 0x00000006,   // PDF file (a PDF file needs to be Ripped before it can be printed)
   eRGB_TIF_FILE = 0x00000007,   // RGB TIFF file (i.e. a TIFF file which needs to be Ripped before it can be printed)
   eXML_LOC_FILE = 0x00000008,   // XML file that contains the location data for mixed mode
   eXML_TEST_PATTERN_FILE = 0x00000009,   // XML file that contains information about how to generate a test pattern like one in the preview image
   eBMP_FILE = 0x0000000A,   // BMP file (.bmp is generally used for preview files but can sometimes contain raster print data)
   ePNG_FILE = 0x0000000B,   // PNG file
   eJPG_FILE = 0x0000000C,   // JPG file
   ePRINTABLE_BMP_FILE = 0x0000000D,   // BMP file containing printable raster data
} eImageFileType;

// Options for over-riding the configured nozzle compensation mode on a per-document basis
// This can be useful when printing test patterns for identifying which nozzles are missing
typedef enum {
   NozzleComp_NoOverride = 0x00000000,   // No override
   NozzleComp_FireAllNozzles = 0x00000001,   // Fire all nozzles which are marked as missing (i.e. suspend all nozzle compensation functionality for the document)
   NozzleComp_NoFireMissingNozzles = 0x00000002,   // Disable all nozzles which are marked as missing, but don't carry out any compensation
   NozzleComp_CompensateMissingNozzles = 0x00000003,   // Disable and compensate for all nozzles which are marked as missing
} NozzleCompOverride;

// The file contains data to print each stitch-band separately, overriding the normal stitch settings.
// It is a custom test pattern generated by Meteor.
typedef enum {
   Stitch_NoOverride = 0x00000000,   // No override.
   Stitch_LowerHeadOnly = 0x00000001,   // Print all data sent with the lower head. While this is enabled, all stitching is ignored.
   Stitch_UpperHeadOnly = 0x00000002,   // Print all data sent in the upper head stitch-band. If the data is not in the stitch-band, it is ignored.
                                        // While this is enabled, all stitching is ignored.
} StitchOverride;

// EEPROM control API commands
typedef enum {
   EGetData = 0x00000000,   // get cached EEPROM data
   EForceRead = 0x00000001,   // force read EEPROM data from scratch
   EWrite = 0x00000002,   // write EEPROM data
   EGetState = 0x00000003,   // get EEPROM handler operation status
} TEepromCtrl_Cmd;

// EEPROM control states
typedef enum {
   EIdle = 0x00000000,   // idle, ready to accept commands
   EBusy = 0x00000001,   // busy, executing current command
   EFailed = 0x00000002,   // requested operation failed
} TEepromCtrl_Stat;

// EEPROM control API user context structure.
typedef struct {
   int32   StructureSizeBytes;   // Size of this structure in bytes.  Must be filled in by the user.
   TEepromCtrl_Cmd   Cmd;   // Command
   TEepromCtrl_Stat   Status;   // Out: Control status
   uint32   Addr;   // EEPROM operation start address
   uint32   NumDataItems;   // in: number of data items to read/write out: actual number of items read/written
   uint8   Data[128];   // in: write data, out: read data
} TEepromCtrl;

// Parameters for the PiCreateStatusReport API
typedef struct {
   int32   StructureSizeBytes;   // Size of this structure in bytes.  Must be filled in by the user.
   uint32   CtrlFlags;   // Control bit flags.
                         // Set Bit0 to include *.sim files into the status report.
                         // Set Bit1 to return as soon as the status report batch file is launched, default is to wait for it to complete.
   char   UserMessage[256];   // Optional user message to log
} TStatusReportParams;

// Status request types. 
// Enum member specifies which status structure is being requested.
// Sent as the 'aStatreq' parameter to the unmanaged PiGetStatusEx function.
typedef enum {
   STATUS_PRINTER = 0x00000000,   // Request the global printer state, TAppStatus
   STATUS_PCC = 0x00000001,   // Request TAppPccStatus
   STATUS_HEAD = 0x00000002,   // Request TAppHeadStatus
   STATUS_COMPACT_FLASH = 0x00000003,   // Request TCompactFlashStatus
   STATUS_DROP_TUNER = 0x00000004,   // Request DropTunerStatus
   STATUS_CONTINUOUS_PRINT = 0x00000005,   // Request TContinuousPrintStatus
   STATUS_RESERVED0 = 0x00000006,   // Reserved/deprecated
   STATUS_RESERVED1 = 0x00000007,   // Reserved/deprecated
   STATUS_SG1024_EEPROM = 0x00000008,   // Deprecated, use STATUS_EEPROM_DATA instead
   STATUS_RESERVED2 = 0x00000009,   // Reserved/deprecated
   STATUS_RG5_EEPROM = 0x0000000A,   // Deprecated, use STATUS_EEPROM_DATA instead
   STATUS_SWATHSEPARATOR = 0x0000000B,   // Request SwathSeparatorStatus (for ScanEngine SDK internal use only)
   STATUS_SWATHDETAILS = 0x0000000C,   // Request SwathDetails (for ScanEngine SDK internal use only)
   STATUS_EEPROM_DATA = 0x0000000D,   // Generic request for head EEPROM contents in JSON format
   STATUS_HDC_SERIAL_NUM = 0x0000000E,   // Request HDC ATSHA serial number
   STATUS_PCC_SERIAL_NUM = 0x0000000F,   // Request PCC ATSHA serial number
   STATUS_PLANE_CONFIG = 0x00000010,   // Request for plane config status (MeteorPlaneConfig)
   STATUS_CONFIG_DESCRIPTOR = 0x00000011,   // Request for config. descriptor status
   STATUS_GEOMETRYSUMMARY = 0x00000012,   // Request geometry summary (for ScanEngine SDK internal use only)
   STATUS_GEOMETRYDETAILS = 0x00000013,   // Request geometry details (for ScanEngine SDK internal use only)
   STATUS_PCC_FPGA_SETUP = 0x00000014,   // Request TPccFpgaSetup
   STATUS_ENUM_COUNT = 0x00000015,   // must be the last member of this enum
} eSTATUSTYPE;

// Extended signals, which take more than one dword of data, used with PiSetSignalEx
typedef enum {
   SIGEX_PRODUCT_DETECT_QUEUE = 0x000003E8,   // A queue for generating sets of internal product detects at different print intervals is available on Ethernet hardware.
                                              // Each entry in the queue generates P product detects at an interval of I print clocks.
                                              // I is the interval *after* a product detect is generated, before the next product detect.
                                              // The queue holds up to 128 P,I pairs.
                                              // SIGEX_PRODUCT_DETECT_QUEUE is used to start/stop/clear the queue using the control flag bits, and/or to add new entries to the queue.
                                              // The number of DWORDs sent to PiSetSignalEx (the 'dataDwords' parameter) with the SIGEX_PRODUCT_DETECT_QUEUE signal is variable.
                                              // 'dataDwords' must be an odd number, greater than or equal to 3, giving N sets of P,I pairs (where N = (dataDwords-3) / 2).
                                              // It is valid for N to be zero when the control flags are used to start, stop or clear the product detect queue.
                                              // <para />
                                              // data[0] = SIGEX_PRODUCT_DETECT_QUEUE 
                                              // data[1] = Print Engine address: [Bits31:24] PccNum;  [Bits23:16] HdcNum;  [Bits15:0] Unused (should be zero).  PccNum must be the index of a master PCC. 
                                              // data[2] = Control flag bits (see <see cref="T:Ttp.Meteor.PdQueueFlags" />).  Can be zero when adding new entries to the queue.
                                              // data[3 .. N] [Optional] Pairs of product detect count / product detect interval DWORDs
                                              // <para />
                                              // e.g. to clear the queue, set it up with 10 product detects @ 1000 print clock interval, and immediately start the queue, the 'signalData array' is
                                              // { 1000, 0x01000000, 0x3, 10, 1000 }
                                              // or to stop the queue before it has completed, use { 1000, 0x01000000, 0x4 }
   SIGEX_TEST1 = 0x000003E9,   // Test signal for Meteor internal use
   SIGEX_ENCODER_UPDATE = 0x000003EA,   // A FIFO queue for updates to the encoder multiply / divide register, each update is triggered by an absolute X position and direction
                                        // The number of DWORDs sent to PiSetSignalEx (the 'dataDwords' parameter) must be 4
                                        // data[0] = SIGEX_ENCODER_UPDATE
                                        // data[1] = Print Engine address: [Bits31:24] PccNum;  [Bits23:16] HdcNum;  [Bits15:0] Unused (should be zero).  PccNum must be the index of a master PCC. 
                                        // data[2] = [Bit24] Direction 1=Fwd 0=Rev; [Bits23:0] XCount at which the encoder multiply / divide is changed
                                        // data[3] = [Bits31:24] Unused, must be zero; [Bits23:8] New encoder divider; [Bits7:0] New encoder multiplier
                                        // The contents of the register update FIFO queue are cleared by an abort
                                        // The maximum number of pending updates in the queue is 170.  PiSetSignalEx will return RVAL_FULL if the register update queue is full.
   SIGEXTYPE_COUNT = 0x000003EB,   // Count of valid SigExTypes
} SigExTypes;

// Flag bits used with <see cref="F:Ttp.Meteor.SigExTypes.SIGEX_PRODUCT_DETECT_QUEUE" />
typedef enum {
   bmSigExPd_ClearFifo = 0x00000001,   // Clear the product detect FIFO prior to adding the new values (if any)
   bmSigExPd_StartInternalPdQueue = 0x00000002,   // Start generating internal product detects
   bmSigExPd_StopInternalPdQueue = 0x00000004,   // Stop generating internal product detects
   bmSigExPd_StartExternalTrigger = 0x00000008,   // Each PD sequence in the queue is started by the external PD signal
} PdQueueFlags;

// Reports the most recent values written to the PCC hardware registers which control print resolution.
// These values are written when the PCC hardware first connects to the PC, during a start job sequence, and during PiUpdateEncoderResolution.
// Request using PiGetPccFpgaSetup (.NET API) or PiGetStatusEx with status request type STATUS_PCC_FPGA_SETUP (native API).
// Note that if hardware has never been connected, IsMaster and IsHardwareConnected both report false.  The resolution related
// values will update during StartJob irrespective of whether hardware is connected.  BaseXDpi always reports how the configuration 
// file is set up even if hardware is never connected.
typedef struct {
   int32   PccNum;   // Pcc index (1-N) for this record, zero if a status request failed or the requested PCC does not exist
   int32   IsHardwareConnected;   // Is the PCC currently connected to the PC
   int32   IsMaster;   // Is the register set up for a master (1) or a slave (0) PCC
   int32   EncoderMultiplier;   // The most recent encoder multiplier written to the "Encoder Reg" register
   int32   EncoderDivider;   // The most recent encoder divider written to the "Encoder Reg" register
   int32   ResolutionDivider;   // The most recent resolution divider written to the "Encoder Reg" register.
                                // The resolution dividers are set in [Encoder] ResN in the configuration file.
                                // The resulting divider seen by the print clock is EncoderDivider * ResolutionDivider
   int32   BaseXDpi;   // The base XPI for the PCC as set in the Meteor configuration file.  
                       // Mixed head types and/or mixed resolution systems can result in different PCCs having different base XDPIs.
   int32   JobXDpi;   // The XDPI for the current job, used as part of the encoder multiple / divide calculations
} TPccFpgaSetup;

// Attribute describing the properties of each value in the eCFGPARAMEx enumeration
typedef struct {
   char   CfgFileKey;   // Key for the parameter in the Meteor configuration file
   int32   Scale;   // Scaling factor for parameter
} CfgExAttribute;

// Definitions of number formats
typedef enum {
   Hex = 0x00000000,   // Define the constant as a hexadecimal value for unmanaged code (default formatting)
   Unsigned = 0x00000001,   // Define the constant as an unsigned value for unmanaged code
} NumberFormat;


#endif // MeteorH
